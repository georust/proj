/* automatically generated by rust-bindgen 0.60.1 */
/* THESE ARE NOT LIVE BINDINGS */
/* THEY EXIST FOR USE BY DOCS-RS ONLY */

pub const PROJ_VERSION_MAJOR: u32 = 9;
pub const PROJ_VERSION_MINOR: u32 = 1;
pub const PROJ_VERSION_PATCH: u32 = 0;
pub const PJ_DEFAULT_CTX: u32 = 0;
pub const PROJ_ERR_INVALID_OP: u32 = 1024;
pub const PROJ_ERR_INVALID_OP_WRONG_SYNTAX: u32 = 1025;
pub const PROJ_ERR_INVALID_OP_MISSING_ARG: u32 = 1026;
pub const PROJ_ERR_INVALID_OP_ILLEGAL_ARG_VALUE: u32 = 1027;
pub const PROJ_ERR_INVALID_OP_MUTUALLY_EXCLUSIVE_ARGS: u32 = 1028;
pub const PROJ_ERR_INVALID_OP_FILE_NOT_FOUND_OR_INVALID: u32 = 1029;
pub const PROJ_ERR_COORD_TRANSFM: u32 = 2048;
pub const PROJ_ERR_COORD_TRANSFM_INVALID_COORD: u32 = 2049;
pub const PROJ_ERR_COORD_TRANSFM_OUTSIDE_PROJECTION_DOMAIN: u32 = 2050;
pub const PROJ_ERR_COORD_TRANSFM_NO_OPERATION: u32 = 2051;
pub const PROJ_ERR_COORD_TRANSFM_OUTSIDE_GRID: u32 = 2052;
pub const PROJ_ERR_COORD_TRANSFM_GRID_AT_NODATA: u32 = 2053;
pub const PROJ_ERR_OTHER: u32 = 4096;
pub const PROJ_ERR_OTHER_API_MISUSE: u32 = 4097;
pub const PROJ_ERR_OTHER_NO_INVERSE_OP: u32 = 4098;
pub const PROJ_ERR_OTHER_NETWORK_ERROR: u32 = 4099;
pub type wchar_t = ::std::os::raw::c_int;
extern "C" {
    pub static mut pj_release: [::std::os::raw::c_char; 0usize];
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PJ_AREA {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct P5_FACTORS {
    pub meridional_scale: f64,
    pub parallel_scale: f64,
    pub areal_scale: f64,
    pub angular_distortion: f64,
    pub meridian_parallel_angle: f64,
    pub meridian_convergence: f64,
    pub tissot_semimajor: f64,
    pub tissot_semiminor: f64,
    pub dx_dlam: f64,
    pub dx_dphi: f64,
    pub dy_dlam: f64,
    pub dy_dphi: f64,
}
#[test]
fn bindgen_test_layout_P5_FACTORS() {
    assert_eq!(
        ::std::mem::size_of::<P5_FACTORS>(),
        96usize,
        concat!("Size of: ", stringify!(P5_FACTORS))
    );
    assert_eq!(
        ::std::mem::align_of::<P5_FACTORS>(),
        8usize,
        concat!("Alignment of ", stringify!(P5_FACTORS))
    );
    fn test_field_meridional_scale() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<P5_FACTORS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).meridional_scale) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(P5_FACTORS),
                "::",
                stringify!(meridional_scale)
            )
        );
    }
    test_field_meridional_scale();
    fn test_field_parallel_scale() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<P5_FACTORS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).parallel_scale) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(P5_FACTORS),
                "::",
                stringify!(parallel_scale)
            )
        );
    }
    test_field_parallel_scale();
    fn test_field_areal_scale() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<P5_FACTORS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).areal_scale) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(P5_FACTORS),
                "::",
                stringify!(areal_scale)
            )
        );
    }
    test_field_areal_scale();
    fn test_field_angular_distortion() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<P5_FACTORS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).angular_distortion) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(P5_FACTORS),
                "::",
                stringify!(angular_distortion)
            )
        );
    }
    test_field_angular_distortion();
    fn test_field_meridian_parallel_angle() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<P5_FACTORS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).meridian_parallel_angle) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(P5_FACTORS),
                "::",
                stringify!(meridian_parallel_angle)
            )
        );
    }
    test_field_meridian_parallel_angle();
    fn test_field_meridian_convergence() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<P5_FACTORS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).meridian_convergence) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(P5_FACTORS),
                "::",
                stringify!(meridian_convergence)
            )
        );
    }
    test_field_meridian_convergence();
    fn test_field_tissot_semimajor() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<P5_FACTORS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tissot_semimajor) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(P5_FACTORS),
                "::",
                stringify!(tissot_semimajor)
            )
        );
    }
    test_field_tissot_semimajor();
    fn test_field_tissot_semiminor() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<P5_FACTORS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tissot_semiminor) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(P5_FACTORS),
                "::",
                stringify!(tissot_semiminor)
            )
        );
    }
    test_field_tissot_semiminor();
    fn test_field_dx_dlam() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<P5_FACTORS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dx_dlam) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(P5_FACTORS),
                "::",
                stringify!(dx_dlam)
            )
        );
    }
    test_field_dx_dlam();
    fn test_field_dx_dphi() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<P5_FACTORS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dx_dphi) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(P5_FACTORS),
                "::",
                stringify!(dx_dphi)
            )
        );
    }
    test_field_dx_dphi();
    fn test_field_dy_dlam() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<P5_FACTORS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dy_dlam) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(P5_FACTORS),
                "::",
                stringify!(dy_dlam)
            )
        );
    }
    test_field_dy_dlam();
    fn test_field_dy_dphi() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<P5_FACTORS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dy_dphi) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(P5_FACTORS),
                "::",
                stringify!(dy_dphi)
            )
        );
    }
    test_field_dy_dphi();
}
pub type PJ_FACTORS = P5_FACTORS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PJconsts {
    _unused: [u8; 0],
}
pub type PJ = PJconsts;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PJ_LIST {
    pub id: *const ::std::os::raw::c_char,
    pub proj: ::std::option::Option<unsafe extern "C" fn(arg1: *mut PJ) -> *mut PJ>,
    pub descr: *const *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_PJ_LIST() {
    assert_eq!(
        ::std::mem::size_of::<PJ_LIST>(),
        24usize,
        concat!("Size of: ", stringify!(PJ_LIST))
    );
    assert_eq!(
        ::std::mem::align_of::<PJ_LIST>(),
        8usize,
        concat!("Alignment of ", stringify!(PJ_LIST))
    );
    fn test_field_id() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PJ_LIST>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(PJ_LIST),
                "::",
                stringify!(id)
            )
        );
    }
    test_field_id();
    fn test_field_proj() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PJ_LIST>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).proj) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(PJ_LIST),
                "::",
                stringify!(proj)
            )
        );
    }
    test_field_proj();
    fn test_field_descr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PJ_LIST>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).descr) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(PJ_LIST),
                "::",
                stringify!(descr)
            )
        );
    }
    test_field_descr();
}
pub type PJ_OPERATIONS = PJ_LIST;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PJ_ELLPS {
    pub id: *const ::std::os::raw::c_char,
    pub major: *const ::std::os::raw::c_char,
    pub ell: *const ::std::os::raw::c_char,
    pub name: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_PJ_ELLPS() {
    assert_eq!(
        ::std::mem::size_of::<PJ_ELLPS>(),
        32usize,
        concat!("Size of: ", stringify!(PJ_ELLPS))
    );
    assert_eq!(
        ::std::mem::align_of::<PJ_ELLPS>(),
        8usize,
        concat!("Alignment of ", stringify!(PJ_ELLPS))
    );
    fn test_field_id() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PJ_ELLPS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(PJ_ELLPS),
                "::",
                stringify!(id)
            )
        );
    }
    test_field_id();
    fn test_field_major() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PJ_ELLPS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).major) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(PJ_ELLPS),
                "::",
                stringify!(major)
            )
        );
    }
    test_field_major();
    fn test_field_ell() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PJ_ELLPS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ell) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(PJ_ELLPS),
                "::",
                stringify!(ell)
            )
        );
    }
    test_field_ell();
    fn test_field_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PJ_ELLPS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(PJ_ELLPS),
                "::",
                stringify!(name)
            )
        );
    }
    test_field_name();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PJ_UNITS {
    pub id: *const ::std::os::raw::c_char,
    pub to_meter: *const ::std::os::raw::c_char,
    pub name: *const ::std::os::raw::c_char,
    pub factor: f64,
}
#[test]
fn bindgen_test_layout_PJ_UNITS() {
    assert_eq!(
        ::std::mem::size_of::<PJ_UNITS>(),
        32usize,
        concat!("Size of: ", stringify!(PJ_UNITS))
    );
    assert_eq!(
        ::std::mem::align_of::<PJ_UNITS>(),
        8usize,
        concat!("Alignment of ", stringify!(PJ_UNITS))
    );
    fn test_field_id() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PJ_UNITS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(PJ_UNITS),
                "::",
                stringify!(id)
            )
        );
    }
    test_field_id();
    fn test_field_to_meter() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PJ_UNITS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).to_meter) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(PJ_UNITS),
                "::",
                stringify!(to_meter)
            )
        );
    }
    test_field_to_meter();
    fn test_field_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PJ_UNITS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(PJ_UNITS),
                "::",
                stringify!(name)
            )
        );
    }
    test_field_name();
    fn test_field_factor() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PJ_UNITS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).factor) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(PJ_UNITS),
                "::",
                stringify!(factor)
            )
        );
    }
    test_field_factor();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PJ_PRIME_MERIDIANS {
    pub id: *const ::std::os::raw::c_char,
    pub defn: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_PJ_PRIME_MERIDIANS() {
    assert_eq!(
        ::std::mem::size_of::<PJ_PRIME_MERIDIANS>(),
        16usize,
        concat!("Size of: ", stringify!(PJ_PRIME_MERIDIANS))
    );
    assert_eq!(
        ::std::mem::align_of::<PJ_PRIME_MERIDIANS>(),
        8usize,
        concat!("Alignment of ", stringify!(PJ_PRIME_MERIDIANS))
    );
    fn test_field_id() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PJ_PRIME_MERIDIANS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(PJ_PRIME_MERIDIANS),
                "::",
                stringify!(id)
            )
        );
    }
    test_field_id();
    fn test_field_defn() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PJ_PRIME_MERIDIANS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).defn) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(PJ_PRIME_MERIDIANS),
                "::",
                stringify!(defn)
            )
        );
    }
    test_field_defn();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PJ_XYZT {
    pub x: f64,
    pub y: f64,
    pub z: f64,
    pub t: f64,
}
#[test]
fn bindgen_test_layout_PJ_XYZT() {
    assert_eq!(
        ::std::mem::size_of::<PJ_XYZT>(),
        32usize,
        concat!("Size of: ", stringify!(PJ_XYZT))
    );
    assert_eq!(
        ::std::mem::align_of::<PJ_XYZT>(),
        8usize,
        concat!("Alignment of ", stringify!(PJ_XYZT))
    );
    fn test_field_x() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PJ_XYZT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(PJ_XYZT),
                "::",
                stringify!(x)
            )
        );
    }
    test_field_x();
    fn test_field_y() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PJ_XYZT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(PJ_XYZT),
                "::",
                stringify!(y)
            )
        );
    }
    test_field_y();
    fn test_field_z() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PJ_XYZT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).z) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(PJ_XYZT),
                "::",
                stringify!(z)
            )
        );
    }
    test_field_z();
    fn test_field_t() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PJ_XYZT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).t) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(PJ_XYZT),
                "::",
                stringify!(t)
            )
        );
    }
    test_field_t();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PJ_UVWT {
    pub u: f64,
    pub v: f64,
    pub w: f64,
    pub t: f64,
}
#[test]
fn bindgen_test_layout_PJ_UVWT() {
    assert_eq!(
        ::std::mem::size_of::<PJ_UVWT>(),
        32usize,
        concat!("Size of: ", stringify!(PJ_UVWT))
    );
    assert_eq!(
        ::std::mem::align_of::<PJ_UVWT>(),
        8usize,
        concat!("Alignment of ", stringify!(PJ_UVWT))
    );
    fn test_field_u() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PJ_UVWT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).u) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(PJ_UVWT),
                "::",
                stringify!(u)
            )
        );
    }
    test_field_u();
    fn test_field_v() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PJ_UVWT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).v) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(PJ_UVWT),
                "::",
                stringify!(v)
            )
        );
    }
    test_field_v();
    fn test_field_w() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PJ_UVWT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).w) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(PJ_UVWT),
                "::",
                stringify!(w)
            )
        );
    }
    test_field_w();
    fn test_field_t() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PJ_UVWT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).t) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(PJ_UVWT),
                "::",
                stringify!(t)
            )
        );
    }
    test_field_t();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PJ_LPZT {
    pub lam: f64,
    pub phi: f64,
    pub z: f64,
    pub t: f64,
}
#[test]
fn bindgen_test_layout_PJ_LPZT() {
    assert_eq!(
        ::std::mem::size_of::<PJ_LPZT>(),
        32usize,
        concat!("Size of: ", stringify!(PJ_LPZT))
    );
    assert_eq!(
        ::std::mem::align_of::<PJ_LPZT>(),
        8usize,
        concat!("Alignment of ", stringify!(PJ_LPZT))
    );
    fn test_field_lam() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PJ_LPZT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).lam) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(PJ_LPZT),
                "::",
                stringify!(lam)
            )
        );
    }
    test_field_lam();
    fn test_field_phi() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PJ_LPZT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).phi) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(PJ_LPZT),
                "::",
                stringify!(phi)
            )
        );
    }
    test_field_phi();
    fn test_field_z() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PJ_LPZT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).z) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(PJ_LPZT),
                "::",
                stringify!(z)
            )
        );
    }
    test_field_z();
    fn test_field_t() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PJ_LPZT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).t) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(PJ_LPZT),
                "::",
                stringify!(t)
            )
        );
    }
    test_field_t();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PJ_OPK {
    pub o: f64,
    pub p: f64,
    pub k: f64,
}
#[test]
fn bindgen_test_layout_PJ_OPK() {
    assert_eq!(
        ::std::mem::size_of::<PJ_OPK>(),
        24usize,
        concat!("Size of: ", stringify!(PJ_OPK))
    );
    assert_eq!(
        ::std::mem::align_of::<PJ_OPK>(),
        8usize,
        concat!("Alignment of ", stringify!(PJ_OPK))
    );
    fn test_field_o() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PJ_OPK>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).o) as usize - ptr as usize
            },
            0usize,
            concat!("Offset of field: ", stringify!(PJ_OPK), "::", stringify!(o))
        );
    }
    test_field_o();
    fn test_field_p() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PJ_OPK>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).p) as usize - ptr as usize
            },
            8usize,
            concat!("Offset of field: ", stringify!(PJ_OPK), "::", stringify!(p))
        );
    }
    test_field_p();
    fn test_field_k() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PJ_OPK>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).k) as usize - ptr as usize
            },
            16usize,
            concat!("Offset of field: ", stringify!(PJ_OPK), "::", stringify!(k))
        );
    }
    test_field_k();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PJ_ENU {
    pub e: f64,
    pub n: f64,
    pub u: f64,
}
#[test]
fn bindgen_test_layout_PJ_ENU() {
    assert_eq!(
        ::std::mem::size_of::<PJ_ENU>(),
        24usize,
        concat!("Size of: ", stringify!(PJ_ENU))
    );
    assert_eq!(
        ::std::mem::align_of::<PJ_ENU>(),
        8usize,
        concat!("Alignment of ", stringify!(PJ_ENU))
    );
    fn test_field_e() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PJ_ENU>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).e) as usize - ptr as usize
            },
            0usize,
            concat!("Offset of field: ", stringify!(PJ_ENU), "::", stringify!(e))
        );
    }
    test_field_e();
    fn test_field_n() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PJ_ENU>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).n) as usize - ptr as usize
            },
            8usize,
            concat!("Offset of field: ", stringify!(PJ_ENU), "::", stringify!(n))
        );
    }
    test_field_n();
    fn test_field_u() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PJ_ENU>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).u) as usize - ptr as usize
            },
            16usize,
            concat!("Offset of field: ", stringify!(PJ_ENU), "::", stringify!(u))
        );
    }
    test_field_u();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PJ_GEOD {
    pub s: f64,
    pub a1: f64,
    pub a2: f64,
}
#[test]
fn bindgen_test_layout_PJ_GEOD() {
    assert_eq!(
        ::std::mem::size_of::<PJ_GEOD>(),
        24usize,
        concat!("Size of: ", stringify!(PJ_GEOD))
    );
    assert_eq!(
        ::std::mem::align_of::<PJ_GEOD>(),
        8usize,
        concat!("Alignment of ", stringify!(PJ_GEOD))
    );
    fn test_field_s() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PJ_GEOD>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).s) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(PJ_GEOD),
                "::",
                stringify!(s)
            )
        );
    }
    test_field_s();
    fn test_field_a1() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PJ_GEOD>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).a1) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(PJ_GEOD),
                "::",
                stringify!(a1)
            )
        );
    }
    test_field_a1();
    fn test_field_a2() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PJ_GEOD>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).a2) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(PJ_GEOD),
                "::",
                stringify!(a2)
            )
        );
    }
    test_field_a2();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PJ_UV {
    pub u: f64,
    pub v: f64,
}
#[test]
fn bindgen_test_layout_PJ_UV() {
    assert_eq!(
        ::std::mem::size_of::<PJ_UV>(),
        16usize,
        concat!("Size of: ", stringify!(PJ_UV))
    );
    assert_eq!(
        ::std::mem::align_of::<PJ_UV>(),
        8usize,
        concat!("Alignment of ", stringify!(PJ_UV))
    );
    fn test_field_u() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PJ_UV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).u) as usize - ptr as usize
            },
            0usize,
            concat!("Offset of field: ", stringify!(PJ_UV), "::", stringify!(u))
        );
    }
    test_field_u();
    fn test_field_v() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PJ_UV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).v) as usize - ptr as usize
            },
            8usize,
            concat!("Offset of field: ", stringify!(PJ_UV), "::", stringify!(v))
        );
    }
    test_field_v();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PJ_XY {
    pub x: f64,
    pub y: f64,
}
#[test]
fn bindgen_test_layout_PJ_XY() {
    assert_eq!(
        ::std::mem::size_of::<PJ_XY>(),
        16usize,
        concat!("Size of: ", stringify!(PJ_XY))
    );
    assert_eq!(
        ::std::mem::align_of::<PJ_XY>(),
        8usize,
        concat!("Alignment of ", stringify!(PJ_XY))
    );
    fn test_field_x() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PJ_XY>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize
            },
            0usize,
            concat!("Offset of field: ", stringify!(PJ_XY), "::", stringify!(x))
        );
    }
    test_field_x();
    fn test_field_y() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PJ_XY>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize
            },
            8usize,
            concat!("Offset of field: ", stringify!(PJ_XY), "::", stringify!(y))
        );
    }
    test_field_y();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PJ_LP {
    pub lam: f64,
    pub phi: f64,
}
#[test]
fn bindgen_test_layout_PJ_LP() {
    assert_eq!(
        ::std::mem::size_of::<PJ_LP>(),
        16usize,
        concat!("Size of: ", stringify!(PJ_LP))
    );
    assert_eq!(
        ::std::mem::align_of::<PJ_LP>(),
        8usize,
        concat!("Alignment of ", stringify!(PJ_LP))
    );
    fn test_field_lam() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PJ_LP>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).lam) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(PJ_LP),
                "::",
                stringify!(lam)
            )
        );
    }
    test_field_lam();
    fn test_field_phi() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PJ_LP>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).phi) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(PJ_LP),
                "::",
                stringify!(phi)
            )
        );
    }
    test_field_phi();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PJ_XYZ {
    pub x: f64,
    pub y: f64,
    pub z: f64,
}
#[test]
fn bindgen_test_layout_PJ_XYZ() {
    assert_eq!(
        ::std::mem::size_of::<PJ_XYZ>(),
        24usize,
        concat!("Size of: ", stringify!(PJ_XYZ))
    );
    assert_eq!(
        ::std::mem::align_of::<PJ_XYZ>(),
        8usize,
        concat!("Alignment of ", stringify!(PJ_XYZ))
    );
    fn test_field_x() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PJ_XYZ>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize
            },
            0usize,
            concat!("Offset of field: ", stringify!(PJ_XYZ), "::", stringify!(x))
        );
    }
    test_field_x();
    fn test_field_y() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PJ_XYZ>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize
            },
            8usize,
            concat!("Offset of field: ", stringify!(PJ_XYZ), "::", stringify!(y))
        );
    }
    test_field_y();
    fn test_field_z() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PJ_XYZ>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).z) as usize - ptr as usize
            },
            16usize,
            concat!("Offset of field: ", stringify!(PJ_XYZ), "::", stringify!(z))
        );
    }
    test_field_z();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PJ_UVW {
    pub u: f64,
    pub v: f64,
    pub w: f64,
}
#[test]
fn bindgen_test_layout_PJ_UVW() {
    assert_eq!(
        ::std::mem::size_of::<PJ_UVW>(),
        24usize,
        concat!("Size of: ", stringify!(PJ_UVW))
    );
    assert_eq!(
        ::std::mem::align_of::<PJ_UVW>(),
        8usize,
        concat!("Alignment of ", stringify!(PJ_UVW))
    );
    fn test_field_u() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PJ_UVW>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).u) as usize - ptr as usize
            },
            0usize,
            concat!("Offset of field: ", stringify!(PJ_UVW), "::", stringify!(u))
        );
    }
    test_field_u();
    fn test_field_v() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PJ_UVW>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).v) as usize - ptr as usize
            },
            8usize,
            concat!("Offset of field: ", stringify!(PJ_UVW), "::", stringify!(v))
        );
    }
    test_field_v();
    fn test_field_w() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PJ_UVW>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).w) as usize - ptr as usize
            },
            16usize,
            concat!("Offset of field: ", stringify!(PJ_UVW), "::", stringify!(w))
        );
    }
    test_field_w();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PJ_LPZ {
    pub lam: f64,
    pub phi: f64,
    pub z: f64,
}
#[test]
fn bindgen_test_layout_PJ_LPZ() {
    assert_eq!(
        ::std::mem::size_of::<PJ_LPZ>(),
        24usize,
        concat!("Size of: ", stringify!(PJ_LPZ))
    );
    assert_eq!(
        ::std::mem::align_of::<PJ_LPZ>(),
        8usize,
        concat!("Alignment of ", stringify!(PJ_LPZ))
    );
    fn test_field_lam() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PJ_LPZ>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).lam) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(PJ_LPZ),
                "::",
                stringify!(lam)
            )
        );
    }
    test_field_lam();
    fn test_field_phi() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PJ_LPZ>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).phi) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(PJ_LPZ),
                "::",
                stringify!(phi)
            )
        );
    }
    test_field_phi();
    fn test_field_z() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PJ_LPZ>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).z) as usize - ptr as usize
            },
            16usize,
            concat!("Offset of field: ", stringify!(PJ_LPZ), "::", stringify!(z))
        );
    }
    test_field_z();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union PJ_COORD {
    pub v: [f64; 4usize],
    pub xyzt: PJ_XYZT,
    pub uvwt: PJ_UVWT,
    pub lpzt: PJ_LPZT,
    pub geod: PJ_GEOD,
    pub opk: PJ_OPK,
    pub enu: PJ_ENU,
    pub xyz: PJ_XYZ,
    pub uvw: PJ_UVW,
    pub lpz: PJ_LPZ,
    pub xy: PJ_XY,
    pub uv: PJ_UV,
    pub lp: PJ_LP,
}
#[test]
fn bindgen_test_layout_PJ_COORD() {
    assert_eq!(
        ::std::mem::size_of::<PJ_COORD>(),
        32usize,
        concat!("Size of: ", stringify!(PJ_COORD))
    );
    assert_eq!(
        ::std::mem::align_of::<PJ_COORD>(),
        8usize,
        concat!("Alignment of ", stringify!(PJ_COORD))
    );
    fn test_field_v() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PJ_COORD>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).v) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(PJ_COORD),
                "::",
                stringify!(v)
            )
        );
    }
    test_field_v();
    fn test_field_xyzt() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PJ_COORD>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).xyzt) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(PJ_COORD),
                "::",
                stringify!(xyzt)
            )
        );
    }
    test_field_xyzt();
    fn test_field_uvwt() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PJ_COORD>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).uvwt) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(PJ_COORD),
                "::",
                stringify!(uvwt)
            )
        );
    }
    test_field_uvwt();
    fn test_field_lpzt() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PJ_COORD>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).lpzt) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(PJ_COORD),
                "::",
                stringify!(lpzt)
            )
        );
    }
    test_field_lpzt();
    fn test_field_geod() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PJ_COORD>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).geod) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(PJ_COORD),
                "::",
                stringify!(geod)
            )
        );
    }
    test_field_geod();
    fn test_field_opk() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PJ_COORD>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).opk) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(PJ_COORD),
                "::",
                stringify!(opk)
            )
        );
    }
    test_field_opk();
    fn test_field_enu() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PJ_COORD>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).enu) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(PJ_COORD),
                "::",
                stringify!(enu)
            )
        );
    }
    test_field_enu();
    fn test_field_xyz() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PJ_COORD>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).xyz) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(PJ_COORD),
                "::",
                stringify!(xyz)
            )
        );
    }
    test_field_xyz();
    fn test_field_uvw() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PJ_COORD>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).uvw) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(PJ_COORD),
                "::",
                stringify!(uvw)
            )
        );
    }
    test_field_uvw();
    fn test_field_lpz() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PJ_COORD>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).lpz) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(PJ_COORD),
                "::",
                stringify!(lpz)
            )
        );
    }
    test_field_lpz();
    fn test_field_xy() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PJ_COORD>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).xy) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(PJ_COORD),
                "::",
                stringify!(xy)
            )
        );
    }
    test_field_xy();
    fn test_field_uv() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PJ_COORD>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).uv) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(PJ_COORD),
                "::",
                stringify!(uv)
            )
        );
    }
    test_field_uv();
    fn test_field_lp() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PJ_COORD>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).lp) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(PJ_COORD),
                "::",
                stringify!(lp)
            )
        );
    }
    test_field_lp();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PJ_INFO {
    pub major: ::std::os::raw::c_int,
    pub minor: ::std::os::raw::c_int,
    pub patch: ::std::os::raw::c_int,
    pub release: *const ::std::os::raw::c_char,
    pub version: *const ::std::os::raw::c_char,
    pub searchpath: *const ::std::os::raw::c_char,
    pub paths: *const *const ::std::os::raw::c_char,
    pub path_count: usize,
}
#[test]
fn bindgen_test_layout_PJ_INFO() {
    assert_eq!(
        ::std::mem::size_of::<PJ_INFO>(),
        56usize,
        concat!("Size of: ", stringify!(PJ_INFO))
    );
    assert_eq!(
        ::std::mem::align_of::<PJ_INFO>(),
        8usize,
        concat!("Alignment of ", stringify!(PJ_INFO))
    );
    fn test_field_major() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PJ_INFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).major) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(PJ_INFO),
                "::",
                stringify!(major)
            )
        );
    }
    test_field_major();
    fn test_field_minor() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PJ_INFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).minor) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(PJ_INFO),
                "::",
                stringify!(minor)
            )
        );
    }
    test_field_minor();
    fn test_field_patch() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PJ_INFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).patch) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(PJ_INFO),
                "::",
                stringify!(patch)
            )
        );
    }
    test_field_patch();
    fn test_field_release() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PJ_INFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).release) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(PJ_INFO),
                "::",
                stringify!(release)
            )
        );
    }
    test_field_release();
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PJ_INFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(PJ_INFO),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_searchpath() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PJ_INFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).searchpath) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(PJ_INFO),
                "::",
                stringify!(searchpath)
            )
        );
    }
    test_field_searchpath();
    fn test_field_paths() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PJ_INFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).paths) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(PJ_INFO),
                "::",
                stringify!(paths)
            )
        );
    }
    test_field_paths();
    fn test_field_path_count() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PJ_INFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).path_count) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(PJ_INFO),
                "::",
                stringify!(path_count)
            )
        );
    }
    test_field_path_count();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PJ_PROJ_INFO {
    pub id: *const ::std::os::raw::c_char,
    pub description: *const ::std::os::raw::c_char,
    pub definition: *const ::std::os::raw::c_char,
    pub has_inverse: ::std::os::raw::c_int,
    pub accuracy: f64,
}
#[test]
fn bindgen_test_layout_PJ_PROJ_INFO() {
    assert_eq!(
        ::std::mem::size_of::<PJ_PROJ_INFO>(),
        40usize,
        concat!("Size of: ", stringify!(PJ_PROJ_INFO))
    );
    assert_eq!(
        ::std::mem::align_of::<PJ_PROJ_INFO>(),
        8usize,
        concat!("Alignment of ", stringify!(PJ_PROJ_INFO))
    );
    fn test_field_id() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PJ_PROJ_INFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(PJ_PROJ_INFO),
                "::",
                stringify!(id)
            )
        );
    }
    test_field_id();
    fn test_field_description() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PJ_PROJ_INFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).description) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(PJ_PROJ_INFO),
                "::",
                stringify!(description)
            )
        );
    }
    test_field_description();
    fn test_field_definition() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PJ_PROJ_INFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).definition) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(PJ_PROJ_INFO),
                "::",
                stringify!(definition)
            )
        );
    }
    test_field_definition();
    fn test_field_has_inverse() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PJ_PROJ_INFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).has_inverse) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(PJ_PROJ_INFO),
                "::",
                stringify!(has_inverse)
            )
        );
    }
    test_field_has_inverse();
    fn test_field_accuracy() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PJ_PROJ_INFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).accuracy) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(PJ_PROJ_INFO),
                "::",
                stringify!(accuracy)
            )
        );
    }
    test_field_accuracy();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PJ_GRID_INFO {
    pub gridname: [::std::os::raw::c_char; 32usize],
    pub filename: [::std::os::raw::c_char; 260usize],
    pub format: [::std::os::raw::c_char; 8usize],
    pub lowerleft: PJ_LP,
    pub upperright: PJ_LP,
    pub n_lon: ::std::os::raw::c_int,
    pub n_lat: ::std::os::raw::c_int,
    pub cs_lon: f64,
    pub cs_lat: f64,
}
#[test]
fn bindgen_test_layout_PJ_GRID_INFO() {
    assert_eq!(
        ::std::mem::size_of::<PJ_GRID_INFO>(),
        360usize,
        concat!("Size of: ", stringify!(PJ_GRID_INFO))
    );
    assert_eq!(
        ::std::mem::align_of::<PJ_GRID_INFO>(),
        8usize,
        concat!("Alignment of ", stringify!(PJ_GRID_INFO))
    );
    fn test_field_gridname() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PJ_GRID_INFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).gridname) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(PJ_GRID_INFO),
                "::",
                stringify!(gridname)
            )
        );
    }
    test_field_gridname();
    fn test_field_filename() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PJ_GRID_INFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).filename) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(PJ_GRID_INFO),
                "::",
                stringify!(filename)
            )
        );
    }
    test_field_filename();
    fn test_field_format() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PJ_GRID_INFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).format) as usize - ptr as usize
            },
            292usize,
            concat!(
                "Offset of field: ",
                stringify!(PJ_GRID_INFO),
                "::",
                stringify!(format)
            )
        );
    }
    test_field_format();
    fn test_field_lowerleft() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PJ_GRID_INFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).lowerleft) as usize - ptr as usize
            },
            304usize,
            concat!(
                "Offset of field: ",
                stringify!(PJ_GRID_INFO),
                "::",
                stringify!(lowerleft)
            )
        );
    }
    test_field_lowerleft();
    fn test_field_upperright() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PJ_GRID_INFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).upperright) as usize - ptr as usize
            },
            320usize,
            concat!(
                "Offset of field: ",
                stringify!(PJ_GRID_INFO),
                "::",
                stringify!(upperright)
            )
        );
    }
    test_field_upperright();
    fn test_field_n_lon() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PJ_GRID_INFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).n_lon) as usize - ptr as usize
            },
            336usize,
            concat!(
                "Offset of field: ",
                stringify!(PJ_GRID_INFO),
                "::",
                stringify!(n_lon)
            )
        );
    }
    test_field_n_lon();
    fn test_field_n_lat() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PJ_GRID_INFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).n_lat) as usize - ptr as usize
            },
            340usize,
            concat!(
                "Offset of field: ",
                stringify!(PJ_GRID_INFO),
                "::",
                stringify!(n_lat)
            )
        );
    }
    test_field_n_lat();
    fn test_field_cs_lon() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PJ_GRID_INFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cs_lon) as usize - ptr as usize
            },
            344usize,
            concat!(
                "Offset of field: ",
                stringify!(PJ_GRID_INFO),
                "::",
                stringify!(cs_lon)
            )
        );
    }
    test_field_cs_lon();
    fn test_field_cs_lat() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PJ_GRID_INFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cs_lat) as usize - ptr as usize
            },
            352usize,
            concat!(
                "Offset of field: ",
                stringify!(PJ_GRID_INFO),
                "::",
                stringify!(cs_lat)
            )
        );
    }
    test_field_cs_lat();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PJ_INIT_INFO {
    pub name: [::std::os::raw::c_char; 32usize],
    pub filename: [::std::os::raw::c_char; 260usize],
    pub version: [::std::os::raw::c_char; 32usize],
    pub origin: [::std::os::raw::c_char; 32usize],
    pub lastupdate: [::std::os::raw::c_char; 16usize],
}
#[test]
fn bindgen_test_layout_PJ_INIT_INFO() {
    assert_eq!(
        ::std::mem::size_of::<PJ_INIT_INFO>(),
        372usize,
        concat!("Size of: ", stringify!(PJ_INIT_INFO))
    );
    assert_eq!(
        ::std::mem::align_of::<PJ_INIT_INFO>(),
        1usize,
        concat!("Alignment of ", stringify!(PJ_INIT_INFO))
    );
    fn test_field_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PJ_INIT_INFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(PJ_INIT_INFO),
                "::",
                stringify!(name)
            )
        );
    }
    test_field_name();
    fn test_field_filename() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PJ_INIT_INFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).filename) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(PJ_INIT_INFO),
                "::",
                stringify!(filename)
            )
        );
    }
    test_field_filename();
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PJ_INIT_INFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            292usize,
            concat!(
                "Offset of field: ",
                stringify!(PJ_INIT_INFO),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_origin() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PJ_INIT_INFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).origin) as usize - ptr as usize
            },
            324usize,
            concat!(
                "Offset of field: ",
                stringify!(PJ_INIT_INFO),
                "::",
                stringify!(origin)
            )
        );
    }
    test_field_origin();
    fn test_field_lastupdate() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PJ_INIT_INFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).lastupdate) as usize - ptr as usize
            },
            356usize,
            concat!(
                "Offset of field: ",
                stringify!(PJ_INIT_INFO),
                "::",
                stringify!(lastupdate)
            )
        );
    }
    test_field_lastupdate();
}
pub const PJ_LOG_LEVEL_PJ_LOG_NONE: PJ_LOG_LEVEL = 0;
pub const PJ_LOG_LEVEL_PJ_LOG_ERROR: PJ_LOG_LEVEL = 1;
pub const PJ_LOG_LEVEL_PJ_LOG_DEBUG: PJ_LOG_LEVEL = 2;
pub const PJ_LOG_LEVEL_PJ_LOG_TRACE: PJ_LOG_LEVEL = 3;
pub const PJ_LOG_LEVEL_PJ_LOG_TELL: PJ_LOG_LEVEL = 4;
pub const PJ_LOG_LEVEL_PJ_LOG_DEBUG_MAJOR: PJ_LOG_LEVEL = 2;
pub const PJ_LOG_LEVEL_PJ_LOG_DEBUG_MINOR: PJ_LOG_LEVEL = 3;
pub type PJ_LOG_LEVEL = ::std::os::raw::c_uint;
pub type PJ_LOG_FUNCTION = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_int,
        arg3: *const ::std::os::raw::c_char,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_ctx {
    _unused: [u8; 0],
}
pub type PJ_CONTEXT = pj_ctx;
extern "C" {
    pub fn proj_context_create() -> *mut PJ_CONTEXT;
}
extern "C" {
    pub fn proj_context_destroy(ctx: *mut PJ_CONTEXT) -> *mut PJ_CONTEXT;
}
extern "C" {
    pub fn proj_context_clone(ctx: *mut PJ_CONTEXT) -> *mut PJ_CONTEXT;
}
#[doc = " Callback to resolve a filename to a full path"]
pub type proj_file_finder = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut PJ_CONTEXT,
        arg1: *const ::std::os::raw::c_char,
        user_data: *mut ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_char,
>;
extern "C" {
    #[doc = " @endcond"]
    pub fn proj_context_set_file_finder(
        ctx: *mut PJ_CONTEXT,
        finder: proj_file_finder,
        user_data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn proj_context_set_search_paths(
        ctx: *mut PJ_CONTEXT,
        count_paths: ::std::os::raw::c_int,
        paths: *const *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn proj_context_set_ca_bundle_path(
        ctx: *mut PJ_CONTEXT,
        path: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " @cond Doxygen_Suppress"]
    pub fn proj_context_use_proj4_init_rules(ctx: *mut PJ_CONTEXT, enable: ::std::os::raw::c_int);
}
extern "C" {
    pub fn proj_context_get_use_proj4_init_rules(
        ctx: *mut PJ_CONTEXT,
        from_legacy_code_path: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PROJ_FILE_HANDLE {
    _unused: [u8; 0],
}
#[doc = " Read-only access. Equivalent to \"rb\""]
pub const PROJ_OPEN_ACCESS_PROJ_OPEN_ACCESS_READ_ONLY: PROJ_OPEN_ACCESS = 0;
#[doc = " Read-update access. File should be created if not existing. Equivalent to \"r+b\""]
pub const PROJ_OPEN_ACCESS_PROJ_OPEN_ACCESS_READ_UPDATE: PROJ_OPEN_ACCESS = 1;
#[doc = " Create access. File should be truncated to 0-byte if already existing. Equivalent to \"w+b\""]
pub const PROJ_OPEN_ACCESS_PROJ_OPEN_ACCESS_CREATE: PROJ_OPEN_ACCESS = 2;
#[doc = " Open access / mode"]
pub type PROJ_OPEN_ACCESS = ::std::os::raw::c_uint;
#[doc = " File API callbacks"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PROJ_FILE_API {
    #[doc = " Version of this structure. Should be set to 1 currently."]
    pub version: ::std::os::raw::c_int,
    #[doc = " Open file. Return NULL if error"]
    pub open_cbk: ::std::option::Option<
        unsafe extern "C" fn(
            ctx: *mut PJ_CONTEXT,
            filename: *const ::std::os::raw::c_char,
            access: PROJ_OPEN_ACCESS,
            user_data: *mut ::std::os::raw::c_void,
        ) -> *mut PROJ_FILE_HANDLE,
    >,
    #[doc = " Read sizeBytes into buffer from current position and return number of bytes read"]
    pub read_cbk: ::std::option::Option<
        unsafe extern "C" fn(
            ctx: *mut PJ_CONTEXT,
            arg1: *mut PROJ_FILE_HANDLE,
            buffer: *mut ::std::os::raw::c_void,
            sizeBytes: usize,
            user_data: *mut ::std::os::raw::c_void,
        ) -> usize,
    >,
    #[doc = " Write sizeBytes into buffer from current position and return number of bytes written"]
    pub write_cbk: ::std::option::Option<
        unsafe extern "C" fn(
            ctx: *mut PJ_CONTEXT,
            arg1: *mut PROJ_FILE_HANDLE,
            buffer: *const ::std::os::raw::c_void,
            sizeBytes: usize,
            user_data: *mut ::std::os::raw::c_void,
        ) -> usize,
    >,
    #[doc = " Seek to offset using whence=SEEK_SET/SEEK_CUR/SEEK_END. Return TRUE in case of success"]
    pub seek_cbk: ::std::option::Option<
        unsafe extern "C" fn(
            ctx: *mut PJ_CONTEXT,
            arg1: *mut PROJ_FILE_HANDLE,
            offset: ::std::os::raw::c_longlong,
            whence: ::std::os::raw::c_int,
            user_data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Return current file position"]
    pub tell_cbk: ::std::option::Option<
        unsafe extern "C" fn(
            ctx: *mut PJ_CONTEXT,
            arg1: *mut PROJ_FILE_HANDLE,
            user_data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_ulonglong,
    >,
    #[doc = " Close file"]
    pub close_cbk: ::std::option::Option<
        unsafe extern "C" fn(
            ctx: *mut PJ_CONTEXT,
            arg1: *mut PROJ_FILE_HANDLE,
            user_data: *mut ::std::os::raw::c_void,
        ),
    >,
    #[doc = " Return TRUE if a file exists"]
    pub exists_cbk: ::std::option::Option<
        unsafe extern "C" fn(
            ctx: *mut PJ_CONTEXT,
            filename: *const ::std::os::raw::c_char,
            user_data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Return TRUE if directory exists or could be created"]
    pub mkdir_cbk: ::std::option::Option<
        unsafe extern "C" fn(
            ctx: *mut PJ_CONTEXT,
            filename: *const ::std::os::raw::c_char,
            user_data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Return TRUE if file could be removed"]
    pub unlink_cbk: ::std::option::Option<
        unsafe extern "C" fn(
            ctx: *mut PJ_CONTEXT,
            filename: *const ::std::os::raw::c_char,
            user_data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Return TRUE if file could be renamed"]
    pub rename_cbk: ::std::option::Option<
        unsafe extern "C" fn(
            ctx: *mut PJ_CONTEXT,
            oldPath: *const ::std::os::raw::c_char,
            newPath: *const ::std::os::raw::c_char,
            user_data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout_PROJ_FILE_API() {
    assert_eq!(
        ::std::mem::size_of::<PROJ_FILE_API>(),
        88usize,
        concat!("Size of: ", stringify!(PROJ_FILE_API))
    );
    assert_eq!(
        ::std::mem::align_of::<PROJ_FILE_API>(),
        8usize,
        concat!("Alignment of ", stringify!(PROJ_FILE_API))
    );
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PROJ_FILE_API>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(PROJ_FILE_API),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_open_cbk() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PROJ_FILE_API>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).open_cbk) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(PROJ_FILE_API),
                "::",
                stringify!(open_cbk)
            )
        );
    }
    test_field_open_cbk();
    fn test_field_read_cbk() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PROJ_FILE_API>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).read_cbk) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(PROJ_FILE_API),
                "::",
                stringify!(read_cbk)
            )
        );
    }
    test_field_read_cbk();
    fn test_field_write_cbk() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PROJ_FILE_API>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).write_cbk) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(PROJ_FILE_API),
                "::",
                stringify!(write_cbk)
            )
        );
    }
    test_field_write_cbk();
    fn test_field_seek_cbk() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PROJ_FILE_API>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).seek_cbk) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(PROJ_FILE_API),
                "::",
                stringify!(seek_cbk)
            )
        );
    }
    test_field_seek_cbk();
    fn test_field_tell_cbk() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PROJ_FILE_API>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tell_cbk) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(PROJ_FILE_API),
                "::",
                stringify!(tell_cbk)
            )
        );
    }
    test_field_tell_cbk();
    fn test_field_close_cbk() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PROJ_FILE_API>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).close_cbk) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(PROJ_FILE_API),
                "::",
                stringify!(close_cbk)
            )
        );
    }
    test_field_close_cbk();
    fn test_field_exists_cbk() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PROJ_FILE_API>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).exists_cbk) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(PROJ_FILE_API),
                "::",
                stringify!(exists_cbk)
            )
        );
    }
    test_field_exists_cbk();
    fn test_field_mkdir_cbk() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PROJ_FILE_API>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mkdir_cbk) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(PROJ_FILE_API),
                "::",
                stringify!(mkdir_cbk)
            )
        );
    }
    test_field_mkdir_cbk();
    fn test_field_unlink_cbk() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PROJ_FILE_API>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).unlink_cbk) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(PROJ_FILE_API),
                "::",
                stringify!(unlink_cbk)
            )
        );
    }
    test_field_unlink_cbk();
    fn test_field_rename_cbk() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PROJ_FILE_API>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rename_cbk) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(PROJ_FILE_API),
                "::",
                stringify!(rename_cbk)
            )
        );
    }
    test_field_rename_cbk();
}
extern "C" {
    pub fn proj_context_set_fileapi(
        ctx: *mut PJ_CONTEXT,
        fileapi: *const PROJ_FILE_API,
        user_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn proj_context_set_sqlite3_vfs_name(
        ctx: *mut PJ_CONTEXT,
        name: *const ::std::os::raw::c_char,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PROJ_NETWORK_HANDLE {
    _unused: [u8; 0],
}
#[doc = " Network access: open callback"]
#[doc = ""]
#[doc = " Should try to read the size_to_read first bytes at the specified offset of"]
#[doc = " the file given by URL url,"]
#[doc = " and write them to buffer. *out_size_read should be updated with the actual"]
#[doc = " amount of bytes read (== size_to_read if the file is larger than size_to_read)."]
#[doc = " During this read, the implementation should make sure to store the HTTP"]
#[doc = " headers from the server response to be able to respond to"]
#[doc = " proj_network_get_header_value_cbk_type callback."]
#[doc = ""]
#[doc = " error_string_max_size should be the maximum size that can be written into"]
#[doc = " the out_error_string buffer (including terminating nul character)."]
#[doc = ""]
#[doc = " @return a non-NULL opaque handle in case of success."]
pub type proj_network_open_cbk_type = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut PJ_CONTEXT,
        url: *const ::std::os::raw::c_char,
        offset: ::std::os::raw::c_ulonglong,
        size_to_read: usize,
        buffer: *mut ::std::os::raw::c_void,
        out_size_read: *mut usize,
        error_string_max_size: usize,
        out_error_string: *mut ::std::os::raw::c_char,
        user_data: *mut ::std::os::raw::c_void,
    ) -> *mut PROJ_NETWORK_HANDLE,
>;
#[doc = " Network access: close callback"]
pub type proj_network_close_cbk_type = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut PJ_CONTEXT,
        handle: *mut PROJ_NETWORK_HANDLE,
        user_data: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " Network access: get HTTP headers"]
pub type proj_network_get_header_value_cbk_type = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut PJ_CONTEXT,
        handle: *mut PROJ_NETWORK_HANDLE,
        header_name: *const ::std::os::raw::c_char,
        user_data: *mut ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_char,
>;
#[doc = " Network access: read range"]
#[doc = ""]
#[doc = " Read size_to_read bytes from handle, starting at offset, into"]
#[doc = " buffer."]
#[doc = " During this read, the implementation should make sure to store the HTTP"]
#[doc = " headers from the server response to be able to respond to"]
#[doc = " proj_network_get_header_value_cbk_type callback."]
#[doc = ""]
#[doc = " error_string_max_size should be the maximum size that can be written into"]
#[doc = " the out_error_string buffer (including terminating nul character)."]
#[doc = ""]
#[doc = " @return the number of bytes actually read (0 in case of error)"]
pub type proj_network_read_range_type = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut PJ_CONTEXT,
        handle: *mut PROJ_NETWORK_HANDLE,
        offset: ::std::os::raw::c_ulonglong,
        size_to_read: usize,
        buffer: *mut ::std::os::raw::c_void,
        error_string_max_size: usize,
        out_error_string: *mut ::std::os::raw::c_char,
        user_data: *mut ::std::os::raw::c_void,
    ) -> usize,
>;
extern "C" {
    pub fn proj_context_set_network_callbacks(
        ctx: *mut PJ_CONTEXT,
        open_cbk: proj_network_open_cbk_type,
        close_cbk: proj_network_close_cbk_type,
        get_header_value_cbk: proj_network_get_header_value_cbk_type,
        read_range_cbk: proj_network_read_range_type,
        user_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn proj_context_set_enable_network(
        ctx: *mut PJ_CONTEXT,
        enabled: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn proj_context_is_network_enabled(ctx: *mut PJ_CONTEXT) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn proj_context_set_url_endpoint(ctx: *mut PJ_CONTEXT, url: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn proj_context_get_url_endpoint(ctx: *mut PJ_CONTEXT) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn proj_context_get_user_writable_directory(
        ctx: *mut PJ_CONTEXT,
        create: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn proj_grid_cache_set_enable(ctx: *mut PJ_CONTEXT, enabled: ::std::os::raw::c_int);
}
extern "C" {
    pub fn proj_grid_cache_set_filename(
        ctx: *mut PJ_CONTEXT,
        fullname: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn proj_grid_cache_set_max_size(ctx: *mut PJ_CONTEXT, max_size_MB: ::std::os::raw::c_int);
}
extern "C" {
    pub fn proj_grid_cache_set_ttl(ctx: *mut PJ_CONTEXT, ttl_seconds: ::std::os::raw::c_int);
}
extern "C" {
    pub fn proj_grid_cache_clear(ctx: *mut PJ_CONTEXT);
}
extern "C" {
    pub fn proj_is_download_needed(
        ctx: *mut PJ_CONTEXT,
        url_or_filename: *const ::std::os::raw::c_char,
        ignore_ttl_setting: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn proj_download_file(
        ctx: *mut PJ_CONTEXT,
        url_or_filename: *const ::std::os::raw::c_char,
        ignore_ttl_setting: ::std::os::raw::c_int,
        progress_cbk: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut PJ_CONTEXT,
                pct: f64,
                user_data: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        user_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @cond Doxygen_Suppress"]
    pub fn proj_create(ctx: *mut PJ_CONTEXT, definition: *const ::std::os::raw::c_char) -> *mut PJ;
}
extern "C" {
    pub fn proj_create_argv(
        ctx: *mut PJ_CONTEXT,
        argc: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
    ) -> *mut PJ;
}
extern "C" {
    pub fn proj_create_crs_to_crs(
        ctx: *mut PJ_CONTEXT,
        source_crs: *const ::std::os::raw::c_char,
        target_crs: *const ::std::os::raw::c_char,
        area: *mut PJ_AREA,
    ) -> *mut PJ;
}
extern "C" {
    pub fn proj_create_crs_to_crs_from_pj(
        ctx: *mut PJ_CONTEXT,
        source_crs: *const PJ,
        target_crs: *const PJ,
        area: *mut PJ_AREA,
        options: *const *const ::std::os::raw::c_char,
    ) -> *mut PJ;
}
extern "C" {
    #[doc = " @endcond"]
    pub fn proj_normalize_for_visualization(ctx: *mut PJ_CONTEXT, obj: *const PJ) -> *mut PJ;
}
extern "C" {
    #[doc = " @cond Doxygen_Suppress"]
    pub fn proj_assign_context(pj: *mut PJ, ctx: *mut PJ_CONTEXT);
}
extern "C" {
    pub fn proj_destroy(P: *mut PJ) -> *mut PJ;
}
extern "C" {
    pub fn proj_area_create() -> *mut PJ_AREA;
}
extern "C" {
    pub fn proj_area_set_bbox(
        area: *mut PJ_AREA,
        west_lon_degree: f64,
        south_lat_degree: f64,
        east_lon_degree: f64,
        north_lat_degree: f64,
    );
}
extern "C" {
    pub fn proj_area_set_name(area: *mut PJ_AREA, name: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn proj_area_destroy(area: *mut PJ_AREA);
}
pub const PJ_DIRECTION_PJ_FWD: PJ_DIRECTION = 1;
pub const PJ_DIRECTION_PJ_IDENT: PJ_DIRECTION = 0;
pub const PJ_DIRECTION_PJ_INV: PJ_DIRECTION = -1;
pub type PJ_DIRECTION = ::std::os::raw::c_int;
extern "C" {
    pub fn proj_angular_input(P: *mut PJ, dir: PJ_DIRECTION) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn proj_angular_output(P: *mut PJ, dir: PJ_DIRECTION) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn proj_degree_input(P: *mut PJ, dir: PJ_DIRECTION) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn proj_degree_output(P: *mut PJ, dir: PJ_DIRECTION) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn proj_trans(P: *mut PJ, direction: PJ_DIRECTION, coord: PJ_COORD) -> PJ_COORD;
}
extern "C" {
    pub fn proj_trans_get_last_used_operation(P: *mut PJ) -> *mut PJ;
}
extern "C" {
    pub fn proj_trans_array(
        P: *mut PJ,
        direction: PJ_DIRECTION,
        n: usize,
        coord: *mut PJ_COORD,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn proj_trans_generic(
        P: *mut PJ,
        direction: PJ_DIRECTION,
        x: *mut f64,
        sx: usize,
        nx: usize,
        y: *mut f64,
        sy: usize,
        ny: usize,
        z: *mut f64,
        sz: usize,
        nz: usize,
        t: *mut f64,
        st: usize,
        nt: usize,
    ) -> usize;
}
extern "C" {
    #[doc = " @endcond"]
    pub fn proj_trans_bounds(
        context: *mut PJ_CONTEXT,
        P: *mut PJ,
        direction: PJ_DIRECTION,
        xmin: f64,
        ymin: f64,
        xmax: f64,
        ymax: f64,
        out_xmin: *mut f64,
        out_ymin: *mut f64,
        out_xmax: *mut f64,
        out_ymax: *mut f64,
        densify_pts: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @cond Doxygen_Suppress"]
    pub fn proj_coord(x: f64, y: f64, z: f64, t: f64) -> PJ_COORD;
}
extern "C" {
    pub fn proj_roundtrip(
        P: *mut PJ,
        direction: PJ_DIRECTION,
        n: ::std::os::raw::c_int,
        coord: *mut PJ_COORD,
    ) -> f64;
}
extern "C" {
    pub fn proj_lp_dist(P: *const PJ, a: PJ_COORD, b: PJ_COORD) -> f64;
}
extern "C" {
    pub fn proj_lpz_dist(P: *const PJ, a: PJ_COORD, b: PJ_COORD) -> f64;
}
extern "C" {
    pub fn proj_xy_dist(a: PJ_COORD, b: PJ_COORD) -> f64;
}
extern "C" {
    pub fn proj_xyz_dist(a: PJ_COORD, b: PJ_COORD) -> f64;
}
extern "C" {
    pub fn proj_geod(P: *const PJ, a: PJ_COORD, b: PJ_COORD) -> PJ_COORD;
}
extern "C" {
    pub fn proj_context_errno(ctx: *mut PJ_CONTEXT) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn proj_errno(P: *const PJ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn proj_errno_set(P: *const PJ, err: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn proj_errno_reset(P: *const PJ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn proj_errno_restore(P: *const PJ, err: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn proj_errno_string(err: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn proj_context_errno_string(
        ctx: *mut PJ_CONTEXT,
        err: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn proj_log_level(ctx: *mut PJ_CONTEXT, log_level: PJ_LOG_LEVEL) -> PJ_LOG_LEVEL;
}
extern "C" {
    pub fn proj_log_func(
        ctx: *mut PJ_CONTEXT,
        app_data: *mut ::std::os::raw::c_void,
        logf: PJ_LOG_FUNCTION,
    );
}
extern "C" {
    pub fn proj_factors(P: *mut PJ, lp: PJ_COORD) -> PJ_FACTORS;
}
extern "C" {
    pub fn proj_info() -> PJ_INFO;
}
extern "C" {
    pub fn proj_pj_info(P: *mut PJ) -> PJ_PROJ_INFO;
}
extern "C" {
    pub fn proj_grid_info(gridname: *const ::std::os::raw::c_char) -> PJ_GRID_INFO;
}
extern "C" {
    pub fn proj_init_info(initname: *const ::std::os::raw::c_char) -> PJ_INIT_INFO;
}
extern "C" {
    pub fn proj_list_operations() -> *const PJ_OPERATIONS;
}
extern "C" {
    pub fn proj_list_ellps() -> *const PJ_ELLPS;
}
extern "C" {
    pub fn proj_list_units() -> *const PJ_UNITS;
}
extern "C" {
    pub fn proj_list_angular_units() -> *const PJ_UNITS;
}
extern "C" {
    pub fn proj_list_prime_meridians() -> *const PJ_PRIME_MERIDIANS;
}
extern "C" {
    pub fn proj_torad(angle_in_degrees: f64) -> f64;
}
extern "C" {
    pub fn proj_todeg(angle_in_radians: f64) -> f64;
}
extern "C" {
    pub fn proj_dmstor(
        is: *const ::std::os::raw::c_char,
        rs: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn proj_rtodms(
        s: *mut ::std::os::raw::c_char,
        r: f64,
        pos: ::std::os::raw::c_int,
        neg: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn proj_cleanup();
}
#[doc = " \\brief Type representing a NULL terminated list of NULL-terminate strings."]
pub type PROJ_STRING_LIST = *mut *mut ::std::os::raw::c_char;
#[doc = " \\ref WKT2_2019"]
pub const PJ_GUESSED_WKT_DIALECT_PJ_GUESSED_WKT2_2019: PJ_GUESSED_WKT_DIALECT = 0;
#[doc = " Deprecated alias for PJ_GUESSED_WKT2_2019"]
pub const PJ_GUESSED_WKT_DIALECT_PJ_GUESSED_WKT2_2018: PJ_GUESSED_WKT_DIALECT = 0;
#[doc = " \\ref WKT2_2015"]
pub const PJ_GUESSED_WKT_DIALECT_PJ_GUESSED_WKT2_2015: PJ_GUESSED_WKT_DIALECT = 1;
#[doc = " \\ref WKT1"]
pub const PJ_GUESSED_WKT_DIALECT_PJ_GUESSED_WKT1_GDAL: PJ_GUESSED_WKT_DIALECT = 2;
#[doc = " ESRI variant of WKT1"]
pub const PJ_GUESSED_WKT_DIALECT_PJ_GUESSED_WKT1_ESRI: PJ_GUESSED_WKT_DIALECT = 3;
#[doc = " Not WKT / unrecognized"]
pub const PJ_GUESSED_WKT_DIALECT_PJ_GUESSED_NOT_WKT: PJ_GUESSED_WKT_DIALECT = 4;
#[doc = " \\brief Guessed WKT \"dialect\"."]
pub type PJ_GUESSED_WKT_DIALECT = ::std::os::raw::c_uint;
pub const PJ_CATEGORY_PJ_CATEGORY_ELLIPSOID: PJ_CATEGORY = 0;
pub const PJ_CATEGORY_PJ_CATEGORY_PRIME_MERIDIAN: PJ_CATEGORY = 1;
pub const PJ_CATEGORY_PJ_CATEGORY_DATUM: PJ_CATEGORY = 2;
pub const PJ_CATEGORY_PJ_CATEGORY_CRS: PJ_CATEGORY = 3;
pub const PJ_CATEGORY_PJ_CATEGORY_COORDINATE_OPERATION: PJ_CATEGORY = 4;
pub const PJ_CATEGORY_PJ_CATEGORY_DATUM_ENSEMBLE: PJ_CATEGORY = 5;
#[doc = " \\brief Object category."]
pub type PJ_CATEGORY = ::std::os::raw::c_uint;
pub const PJ_TYPE_PJ_TYPE_UNKNOWN: PJ_TYPE = 0;
pub const PJ_TYPE_PJ_TYPE_ELLIPSOID: PJ_TYPE = 1;
pub const PJ_TYPE_PJ_TYPE_PRIME_MERIDIAN: PJ_TYPE = 2;
pub const PJ_TYPE_PJ_TYPE_GEODETIC_REFERENCE_FRAME: PJ_TYPE = 3;
pub const PJ_TYPE_PJ_TYPE_DYNAMIC_GEODETIC_REFERENCE_FRAME: PJ_TYPE = 4;
pub const PJ_TYPE_PJ_TYPE_VERTICAL_REFERENCE_FRAME: PJ_TYPE = 5;
pub const PJ_TYPE_PJ_TYPE_DYNAMIC_VERTICAL_REFERENCE_FRAME: PJ_TYPE = 6;
pub const PJ_TYPE_PJ_TYPE_DATUM_ENSEMBLE: PJ_TYPE = 7;
#[doc = " Abstract type, not returned by proj_get_type()"]
pub const PJ_TYPE_PJ_TYPE_CRS: PJ_TYPE = 8;
#[doc = " Abstract type, not returned by proj_get_type()"]
pub const PJ_TYPE_PJ_TYPE_GEODETIC_CRS: PJ_TYPE = 9;
#[doc = " Abstract type, not returned by proj_get_type()"]
pub const PJ_TYPE_PJ_TYPE_GEOCENTRIC_CRS: PJ_TYPE = 10;
#[doc = " proj_get_type() will never return that type, but"]
#[doc = " PJ_TYPE_GEOGRAPHIC_2D_CRS or PJ_TYPE_GEOGRAPHIC_3D_CRS."]
pub const PJ_TYPE_PJ_TYPE_GEOGRAPHIC_CRS: PJ_TYPE = 11;
#[doc = " proj_get_type() will never return that type, but"]
#[doc = " PJ_TYPE_GEOGRAPHIC_2D_CRS or PJ_TYPE_GEOGRAPHIC_3D_CRS."]
pub const PJ_TYPE_PJ_TYPE_GEOGRAPHIC_2D_CRS: PJ_TYPE = 12;
#[doc = " proj_get_type() will never return that type, but"]
#[doc = " PJ_TYPE_GEOGRAPHIC_2D_CRS or PJ_TYPE_GEOGRAPHIC_3D_CRS."]
pub const PJ_TYPE_PJ_TYPE_GEOGRAPHIC_3D_CRS: PJ_TYPE = 13;
#[doc = " proj_get_type() will never return that type, but"]
#[doc = " PJ_TYPE_GEOGRAPHIC_2D_CRS or PJ_TYPE_GEOGRAPHIC_3D_CRS."]
pub const PJ_TYPE_PJ_TYPE_VERTICAL_CRS: PJ_TYPE = 14;
#[doc = " proj_get_type() will never return that type, but"]
#[doc = " PJ_TYPE_GEOGRAPHIC_2D_CRS or PJ_TYPE_GEOGRAPHIC_3D_CRS."]
pub const PJ_TYPE_PJ_TYPE_PROJECTED_CRS: PJ_TYPE = 15;
#[doc = " proj_get_type() will never return that type, but"]
#[doc = " PJ_TYPE_GEOGRAPHIC_2D_CRS or PJ_TYPE_GEOGRAPHIC_3D_CRS."]
pub const PJ_TYPE_PJ_TYPE_COMPOUND_CRS: PJ_TYPE = 16;
#[doc = " proj_get_type() will never return that type, but"]
#[doc = " PJ_TYPE_GEOGRAPHIC_2D_CRS or PJ_TYPE_GEOGRAPHIC_3D_CRS."]
pub const PJ_TYPE_PJ_TYPE_TEMPORAL_CRS: PJ_TYPE = 17;
#[doc = " proj_get_type() will never return that type, but"]
#[doc = " PJ_TYPE_GEOGRAPHIC_2D_CRS or PJ_TYPE_GEOGRAPHIC_3D_CRS."]
pub const PJ_TYPE_PJ_TYPE_ENGINEERING_CRS: PJ_TYPE = 18;
#[doc = " proj_get_type() will never return that type, but"]
#[doc = " PJ_TYPE_GEOGRAPHIC_2D_CRS or PJ_TYPE_GEOGRAPHIC_3D_CRS."]
pub const PJ_TYPE_PJ_TYPE_BOUND_CRS: PJ_TYPE = 19;
#[doc = " proj_get_type() will never return that type, but"]
#[doc = " PJ_TYPE_GEOGRAPHIC_2D_CRS or PJ_TYPE_GEOGRAPHIC_3D_CRS."]
pub const PJ_TYPE_PJ_TYPE_OTHER_CRS: PJ_TYPE = 20;
#[doc = " proj_get_type() will never return that type, but"]
#[doc = " PJ_TYPE_GEOGRAPHIC_2D_CRS or PJ_TYPE_GEOGRAPHIC_3D_CRS."]
pub const PJ_TYPE_PJ_TYPE_CONVERSION: PJ_TYPE = 21;
#[doc = " proj_get_type() will never return that type, but"]
#[doc = " PJ_TYPE_GEOGRAPHIC_2D_CRS or PJ_TYPE_GEOGRAPHIC_3D_CRS."]
pub const PJ_TYPE_PJ_TYPE_TRANSFORMATION: PJ_TYPE = 22;
#[doc = " proj_get_type() will never return that type, but"]
#[doc = " PJ_TYPE_GEOGRAPHIC_2D_CRS or PJ_TYPE_GEOGRAPHIC_3D_CRS."]
pub const PJ_TYPE_PJ_TYPE_CONCATENATED_OPERATION: PJ_TYPE = 23;
#[doc = " proj_get_type() will never return that type, but"]
#[doc = " PJ_TYPE_GEOGRAPHIC_2D_CRS or PJ_TYPE_GEOGRAPHIC_3D_CRS."]
pub const PJ_TYPE_PJ_TYPE_OTHER_COORDINATE_OPERATION: PJ_TYPE = 24;
#[doc = " proj_get_type() will never return that type, but"]
#[doc = " PJ_TYPE_GEOGRAPHIC_2D_CRS or PJ_TYPE_GEOGRAPHIC_3D_CRS."]
pub const PJ_TYPE_PJ_TYPE_TEMPORAL_DATUM: PJ_TYPE = 25;
#[doc = " proj_get_type() will never return that type, but"]
#[doc = " PJ_TYPE_GEOGRAPHIC_2D_CRS or PJ_TYPE_GEOGRAPHIC_3D_CRS."]
pub const PJ_TYPE_PJ_TYPE_ENGINEERING_DATUM: PJ_TYPE = 26;
#[doc = " proj_get_type() will never return that type, but"]
#[doc = " PJ_TYPE_GEOGRAPHIC_2D_CRS or PJ_TYPE_GEOGRAPHIC_3D_CRS."]
pub const PJ_TYPE_PJ_TYPE_PARAMETRIC_DATUM: PJ_TYPE = 27;
#[doc = " \\brief Object type."]
pub type PJ_TYPE = ::std::os::raw::c_uint;
#[doc = " All properties are identical."]
pub const PJ_COMPARISON_CRITERION_PJ_COMP_STRICT: PJ_COMPARISON_CRITERION = 0;
#[doc = " The objects are equivalent for the purpose of coordinate"]
#[doc = " operations. They can differ by the name of their objects,"]
#[doc = " identifiers, other metadata."]
#[doc = " Parameters may be expressed in different units, provided that the"]
#[doc = " value is (with some tolerance) the same once expressed in a"]
#[doc = " common unit."]
pub const PJ_COMPARISON_CRITERION_PJ_COMP_EQUIVALENT: PJ_COMPARISON_CRITERION = 1;
#[doc = " Same as EQUIVALENT, relaxed with an exception that the axis order"]
#[doc = " of the base CRS of a DerivedCRS/ProjectedCRS or the axis order of"]
#[doc = " a GeographicCRS is ignored. Only to be used"]
#[doc = " with DerivedCRS/ProjectedCRS/GeographicCRS"]
pub const PJ_COMPARISON_CRITERION_PJ_COMP_EQUIVALENT_EXCEPT_AXIS_ORDER_GEOGCRS:
    PJ_COMPARISON_CRITERION = 2;
#[doc = " Comparison criterion."]
pub type PJ_COMPARISON_CRITERION = ::std::os::raw::c_uint;
#[doc = " cf osgeo::proj::io::WKTFormatter::Convention::WKT2"]
pub const PJ_WKT_TYPE_PJ_WKT2_2015: PJ_WKT_TYPE = 0;
#[doc = " cf osgeo::proj::io::WKTFormatter::Convention::WKT2_SIMPLIFIED"]
pub const PJ_WKT_TYPE_PJ_WKT2_2015_SIMPLIFIED: PJ_WKT_TYPE = 1;
#[doc = " cf osgeo::proj::io::WKTFormatter::Convention::WKT2_2019"]
pub const PJ_WKT_TYPE_PJ_WKT2_2019: PJ_WKT_TYPE = 2;
#[doc = " Deprecated alias for PJ_WKT2_2019"]
pub const PJ_WKT_TYPE_PJ_WKT2_2018: PJ_WKT_TYPE = 2;
#[doc = " cf osgeo::proj::io::WKTFormatter::Convention::WKT2_2019_SIMPLIFIED"]
pub const PJ_WKT_TYPE_PJ_WKT2_2019_SIMPLIFIED: PJ_WKT_TYPE = 3;
#[doc = " Deprecated alias for PJ_WKT2_2019"]
pub const PJ_WKT_TYPE_PJ_WKT2_2018_SIMPLIFIED: PJ_WKT_TYPE = 3;
#[doc = " cf osgeo::proj::io::WKTFormatter::Convention::WKT1_GDAL"]
pub const PJ_WKT_TYPE_PJ_WKT1_GDAL: PJ_WKT_TYPE = 4;
#[doc = " cf osgeo::proj::io::WKTFormatter::Convention::WKT1_ESRI"]
pub const PJ_WKT_TYPE_PJ_WKT1_ESRI: PJ_WKT_TYPE = 5;
#[doc = " \\brief WKT version."]
pub type PJ_WKT_TYPE = ::std::os::raw::c_uint;
#[doc = " Ignore CRS extent"]
pub const PROJ_CRS_EXTENT_USE_PJ_CRS_EXTENT_NONE: PROJ_CRS_EXTENT_USE = 0;
#[doc = " Test coordinate operation extent against both CRS extent."]
pub const PROJ_CRS_EXTENT_USE_PJ_CRS_EXTENT_BOTH: PROJ_CRS_EXTENT_USE = 1;
#[doc = " Test coordinate operation extent against the intersection of both"]
#[doc = "CRS extent."]
pub const PROJ_CRS_EXTENT_USE_PJ_CRS_EXTENT_INTERSECTION: PROJ_CRS_EXTENT_USE = 2;
#[doc = " Test coordinate operation against the smallest of both CRS extent."]
pub const PROJ_CRS_EXTENT_USE_PJ_CRS_EXTENT_SMALLEST: PROJ_CRS_EXTENT_USE = 3;
#[doc = " Specify how source and target CRS extent should be used to restrict"]
#[doc = " candidate operations (only taken into account if no explicit area of"]
#[doc = " interest is specified."]
pub type PROJ_CRS_EXTENT_USE = ::std::os::raw::c_uint;
#[doc = " Grid availability is only used for sorting results. Operations"]
#[doc = " where some grids are missing will be sorted last."]
pub const PROJ_GRID_AVAILABILITY_USE_PROJ_GRID_AVAILABILITY_USED_FOR_SORTING:
    PROJ_GRID_AVAILABILITY_USE = 0;
#[doc = " Completely discard an operation if a required grid is missing."]
pub const PROJ_GRID_AVAILABILITY_USE_PROJ_GRID_AVAILABILITY_DISCARD_OPERATION_IF_MISSING_GRID:
    PROJ_GRID_AVAILABILITY_USE = 1;
#[doc = " Ignore grid availability at all. Results will be presented as if"]
#[doc = " all grids were available."]
pub const PROJ_GRID_AVAILABILITY_USE_PROJ_GRID_AVAILABILITY_IGNORED: PROJ_GRID_AVAILABILITY_USE = 2;
#[doc = " Results will be presented as if grids known to PROJ (that is"]
#[doc = " registered in the grid_alternatives table of its database) were"]
#[doc = " available. Used typically when networking is enabled."]
pub const PROJ_GRID_AVAILABILITY_USE_PROJ_GRID_AVAILABILITY_KNOWN_AVAILABLE:
    PROJ_GRID_AVAILABILITY_USE = 3;
#[doc = " Describe how grid availability is used."]
pub type PROJ_GRID_AVAILABILITY_USE = ::std::os::raw::c_uint;
#[doc = " cf osgeo::proj::io::PROJStringFormatter::Convention::PROJ_5"]
pub const PJ_PROJ_STRING_TYPE_PJ_PROJ_5: PJ_PROJ_STRING_TYPE = 0;
#[doc = " cf osgeo::proj::io::PROJStringFormatter::Convention::PROJ_4"]
pub const PJ_PROJ_STRING_TYPE_PJ_PROJ_4: PJ_PROJ_STRING_TYPE = 1;
#[doc = " \\brief PROJ string version."]
pub type PJ_PROJ_STRING_TYPE = ::std::os::raw::c_uint;
#[doc = " The area of validity of transforms should strictly contain the"]
#[doc = " are of interest."]
pub const PROJ_SPATIAL_CRITERION_PROJ_SPATIAL_CRITERION_STRICT_CONTAINMENT: PROJ_SPATIAL_CRITERION =
    0;
#[doc = " The area of validity of transforms should at least intersect the"]
#[doc = " area of interest."]
pub const PROJ_SPATIAL_CRITERION_PROJ_SPATIAL_CRITERION_PARTIAL_INTERSECTION:
    PROJ_SPATIAL_CRITERION = 1;
#[doc = " Spatial criterion to restrict candidate operations."]
pub type PROJ_SPATIAL_CRITERION = ::std::os::raw::c_uint;
#[doc = " Always search for intermediate CRS."]
pub const PROJ_INTERMEDIATE_CRS_USE_PROJ_INTERMEDIATE_CRS_USE_ALWAYS: PROJ_INTERMEDIATE_CRS_USE = 0;
#[doc = " Only attempt looking for intermediate CRS if there is no direct"]
#[doc = " transformation available."]
pub const PROJ_INTERMEDIATE_CRS_USE_PROJ_INTERMEDIATE_CRS_USE_IF_NO_DIRECT_TRANSFORMATION:
    PROJ_INTERMEDIATE_CRS_USE = 1;
#[doc = " Only attempt looking for intermediate CRS if there is no direct"]
#[doc = " transformation available."]
pub const PROJ_INTERMEDIATE_CRS_USE_PROJ_INTERMEDIATE_CRS_USE_NEVER: PROJ_INTERMEDIATE_CRS_USE = 2;
#[doc = " Describe if and how intermediate CRS should be used"]
pub type PROJ_INTERMEDIATE_CRS_USE = ::std::os::raw::c_uint;
pub const PJ_COORDINATE_SYSTEM_TYPE_PJ_CS_TYPE_UNKNOWN: PJ_COORDINATE_SYSTEM_TYPE = 0;
pub const PJ_COORDINATE_SYSTEM_TYPE_PJ_CS_TYPE_CARTESIAN: PJ_COORDINATE_SYSTEM_TYPE = 1;
pub const PJ_COORDINATE_SYSTEM_TYPE_PJ_CS_TYPE_ELLIPSOIDAL: PJ_COORDINATE_SYSTEM_TYPE = 2;
pub const PJ_COORDINATE_SYSTEM_TYPE_PJ_CS_TYPE_VERTICAL: PJ_COORDINATE_SYSTEM_TYPE = 3;
pub const PJ_COORDINATE_SYSTEM_TYPE_PJ_CS_TYPE_SPHERICAL: PJ_COORDINATE_SYSTEM_TYPE = 4;
pub const PJ_COORDINATE_SYSTEM_TYPE_PJ_CS_TYPE_ORDINAL: PJ_COORDINATE_SYSTEM_TYPE = 5;
pub const PJ_COORDINATE_SYSTEM_TYPE_PJ_CS_TYPE_PARAMETRIC: PJ_COORDINATE_SYSTEM_TYPE = 6;
pub const PJ_COORDINATE_SYSTEM_TYPE_PJ_CS_TYPE_DATETIMETEMPORAL: PJ_COORDINATE_SYSTEM_TYPE = 7;
pub const PJ_COORDINATE_SYSTEM_TYPE_PJ_CS_TYPE_TEMPORALCOUNT: PJ_COORDINATE_SYSTEM_TYPE = 8;
pub const PJ_COORDINATE_SYSTEM_TYPE_PJ_CS_TYPE_TEMPORALMEASURE: PJ_COORDINATE_SYSTEM_TYPE = 9;
#[doc = " Type of coordinate system."]
pub type PJ_COORDINATE_SYSTEM_TYPE = ::std::os::raw::c_uint;
#[doc = " \\brief Structure given overall description of a CRS."]
#[doc = ""]
#[doc = " This structure may grow over time, and should not be directly allocated by"]
#[doc = " client code."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PROJ_CRS_INFO {
    #[doc = " Authority name."]
    pub auth_name: *mut ::std::os::raw::c_char,
    #[doc = " Object code."]
    pub code: *mut ::std::os::raw::c_char,
    #[doc = " Object name."]
    pub name: *mut ::std::os::raw::c_char,
    #[doc = " Object type."]
    pub type_: PJ_TYPE,
    #[doc = " Whether the object is deprecated"]
    pub deprecated: ::std::os::raw::c_int,
    #[doc = " Whereas the west_lon_degree, south_lat_degree, east_lon_degree and"]
    #[doc = " north_lat_degree fields are valid."]
    pub bbox_valid: ::std::os::raw::c_int,
    #[doc = " Western-most longitude of the area of use, in degrees."]
    pub west_lon_degree: f64,
    #[doc = " Southern-most latitude of the area of use, in degrees."]
    pub south_lat_degree: f64,
    #[doc = " Eastern-most longitude of the area of use, in degrees."]
    pub east_lon_degree: f64,
    #[doc = " Northern-most latitude of the area of use, in degrees."]
    pub north_lat_degree: f64,
    #[doc = " Name of the area of use."]
    pub area_name: *mut ::std::os::raw::c_char,
    #[doc = " Name of the projection method for a projected CRS. Might be NULL even"]
    #[doc = "for projected CRS in some cases."]
    pub projection_method_name: *mut ::std::os::raw::c_char,
    #[doc = " Name of the celestial body of the CRS (e.g. \"Earth\")."]
    #[doc = " @since 8.1"]
    pub celestial_body_name: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_PROJ_CRS_INFO() {
    assert_eq!(
        ::std::mem::size_of::<PROJ_CRS_INFO>(),
        96usize,
        concat!("Size of: ", stringify!(PROJ_CRS_INFO))
    );
    assert_eq!(
        ::std::mem::align_of::<PROJ_CRS_INFO>(),
        8usize,
        concat!("Alignment of ", stringify!(PROJ_CRS_INFO))
    );
    fn test_field_auth_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PROJ_CRS_INFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).auth_name) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(PROJ_CRS_INFO),
                "::",
                stringify!(auth_name)
            )
        );
    }
    test_field_auth_name();
    fn test_field_code() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PROJ_CRS_INFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).code) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(PROJ_CRS_INFO),
                "::",
                stringify!(code)
            )
        );
    }
    test_field_code();
    fn test_field_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PROJ_CRS_INFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(PROJ_CRS_INFO),
                "::",
                stringify!(name)
            )
        );
    }
    test_field_name();
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PROJ_CRS_INFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(PROJ_CRS_INFO),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
    fn test_field_deprecated() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PROJ_CRS_INFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).deprecated) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(PROJ_CRS_INFO),
                "::",
                stringify!(deprecated)
            )
        );
    }
    test_field_deprecated();
    fn test_field_bbox_valid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PROJ_CRS_INFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bbox_valid) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(PROJ_CRS_INFO),
                "::",
                stringify!(bbox_valid)
            )
        );
    }
    test_field_bbox_valid();
    fn test_field_west_lon_degree() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PROJ_CRS_INFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).west_lon_degree) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(PROJ_CRS_INFO),
                "::",
                stringify!(west_lon_degree)
            )
        );
    }
    test_field_west_lon_degree();
    fn test_field_south_lat_degree() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PROJ_CRS_INFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).south_lat_degree) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(PROJ_CRS_INFO),
                "::",
                stringify!(south_lat_degree)
            )
        );
    }
    test_field_south_lat_degree();
    fn test_field_east_lon_degree() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PROJ_CRS_INFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).east_lon_degree) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(PROJ_CRS_INFO),
                "::",
                stringify!(east_lon_degree)
            )
        );
    }
    test_field_east_lon_degree();
    fn test_field_north_lat_degree() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PROJ_CRS_INFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).north_lat_degree) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(PROJ_CRS_INFO),
                "::",
                stringify!(north_lat_degree)
            )
        );
    }
    test_field_north_lat_degree();
    fn test_field_area_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PROJ_CRS_INFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).area_name) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(PROJ_CRS_INFO),
                "::",
                stringify!(area_name)
            )
        );
    }
    test_field_area_name();
    fn test_field_projection_method_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PROJ_CRS_INFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).projection_method_name) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(PROJ_CRS_INFO),
                "::",
                stringify!(projection_method_name)
            )
        );
    }
    test_field_projection_method_name();
    fn test_field_celestial_body_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PROJ_CRS_INFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).celestial_body_name) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(PROJ_CRS_INFO),
                "::",
                stringify!(celestial_body_name)
            )
        );
    }
    test_field_celestial_body_name();
}
#[doc = " \\brief Structure describing optional parameters for proj_get_crs_list();"]
#[doc = ""]
#[doc = " This structure may grow over time, and should not be directly allocated by"]
#[doc = " client code."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PROJ_CRS_LIST_PARAMETERS {
    #[doc = " Array of allowed object types. Should be NULL if all types are allowed"]
    pub types: *const PJ_TYPE,
    #[doc = " Size of types. Should be 0 if all types are allowed"]
    pub typesCount: usize,
    #[doc = " If TRUE and bbox_valid == TRUE, then only CRS whose area of use"]
    #[doc = " entirely contains the specified bounding box will be returned."]
    #[doc = " If FALSE and bbox_valid == TRUE, then only CRS whose area of use"]
    #[doc = " intersects the specified bounding box will be returned."]
    pub crs_area_of_use_contains_bbox: ::std::os::raw::c_int,
    #[doc = " To set to TRUE so that west_lon_degree, south_lat_degree,"]
    #[doc = " east_lon_degree and north_lat_degree fields are taken into account."]
    pub bbox_valid: ::std::os::raw::c_int,
    #[doc = " Western-most longitude of the area of use, in degrees."]
    pub west_lon_degree: f64,
    #[doc = " Southern-most latitude of the area of use, in degrees."]
    pub south_lat_degree: f64,
    #[doc = " Eastern-most longitude of the area of use, in degrees."]
    pub east_lon_degree: f64,
    #[doc = " Northern-most latitude of the area of use, in degrees."]
    pub north_lat_degree: f64,
    #[doc = " Whether deprecated objects are allowed. Default to FALSE."]
    pub allow_deprecated: ::std::os::raw::c_int,
    #[doc = " Celestial body of the CRS (e.g. \"Earth\"). The default value, NULL,"]
    #[doc = "  means no restriction"]
    #[doc = " @since 8.1"]
    pub celestial_body_name: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_PROJ_CRS_LIST_PARAMETERS() {
    assert_eq!(
        ::std::mem::size_of::<PROJ_CRS_LIST_PARAMETERS>(),
        72usize,
        concat!("Size of: ", stringify!(PROJ_CRS_LIST_PARAMETERS))
    );
    assert_eq!(
        ::std::mem::align_of::<PROJ_CRS_LIST_PARAMETERS>(),
        8usize,
        concat!("Alignment of ", stringify!(PROJ_CRS_LIST_PARAMETERS))
    );
    fn test_field_types() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PROJ_CRS_LIST_PARAMETERS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).types) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(PROJ_CRS_LIST_PARAMETERS),
                "::",
                stringify!(types)
            )
        );
    }
    test_field_types();
    fn test_field_typesCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PROJ_CRS_LIST_PARAMETERS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).typesCount) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(PROJ_CRS_LIST_PARAMETERS),
                "::",
                stringify!(typesCount)
            )
        );
    }
    test_field_typesCount();
    fn test_field_crs_area_of_use_contains_bbox() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PROJ_CRS_LIST_PARAMETERS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).crs_area_of_use_contains_bbox) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(PROJ_CRS_LIST_PARAMETERS),
                "::",
                stringify!(crs_area_of_use_contains_bbox)
            )
        );
    }
    test_field_crs_area_of_use_contains_bbox();
    fn test_field_bbox_valid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PROJ_CRS_LIST_PARAMETERS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bbox_valid) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(PROJ_CRS_LIST_PARAMETERS),
                "::",
                stringify!(bbox_valid)
            )
        );
    }
    test_field_bbox_valid();
    fn test_field_west_lon_degree() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PROJ_CRS_LIST_PARAMETERS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).west_lon_degree) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(PROJ_CRS_LIST_PARAMETERS),
                "::",
                stringify!(west_lon_degree)
            )
        );
    }
    test_field_west_lon_degree();
    fn test_field_south_lat_degree() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PROJ_CRS_LIST_PARAMETERS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).south_lat_degree) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(PROJ_CRS_LIST_PARAMETERS),
                "::",
                stringify!(south_lat_degree)
            )
        );
    }
    test_field_south_lat_degree();
    fn test_field_east_lon_degree() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PROJ_CRS_LIST_PARAMETERS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).east_lon_degree) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(PROJ_CRS_LIST_PARAMETERS),
                "::",
                stringify!(east_lon_degree)
            )
        );
    }
    test_field_east_lon_degree();
    fn test_field_north_lat_degree() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PROJ_CRS_LIST_PARAMETERS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).north_lat_degree) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(PROJ_CRS_LIST_PARAMETERS),
                "::",
                stringify!(north_lat_degree)
            )
        );
    }
    test_field_north_lat_degree();
    fn test_field_allow_deprecated() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PROJ_CRS_LIST_PARAMETERS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).allow_deprecated) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(PROJ_CRS_LIST_PARAMETERS),
                "::",
                stringify!(allow_deprecated)
            )
        );
    }
    test_field_allow_deprecated();
    fn test_field_celestial_body_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PROJ_CRS_LIST_PARAMETERS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).celestial_body_name) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(PROJ_CRS_LIST_PARAMETERS),
                "::",
                stringify!(celestial_body_name)
            )
        );
    }
    test_field_celestial_body_name();
}
#[doc = " \\brief Structure given description of a unit."]
#[doc = ""]
#[doc = " This structure may grow over time, and should not be directly allocated by"]
#[doc = " client code."]
#[doc = " @since 7.1"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PROJ_UNIT_INFO {
    #[doc = " Authority name."]
    pub auth_name: *mut ::std::os::raw::c_char,
    #[doc = " Object code."]
    pub code: *mut ::std::os::raw::c_char,
    #[doc = " Object name. For example \"metre\", \"US survey foot\", etc."]
    pub name: *mut ::std::os::raw::c_char,
    #[doc = " Category of the unit: one of \"linear\", \"linear_per_time\", \"angular\","]
    #[doc = " \"angular_per_time\", \"scale\", \"scale_per_time\" or \"time\""]
    pub category: *mut ::std::os::raw::c_char,
    #[doc = " Conversion factor to apply to transform from that unit to the"]
    #[doc = " corresponding SI unit (metre for \"linear\", radian for \"angular\", etc.)."]
    #[doc = " It might be 0 in some cases to indicate no known conversion factor."]
    pub conv_factor: f64,
    #[doc = " PROJ short name, like \"m\", \"ft\", \"us-ft\", etc... Might be NULL"]
    pub proj_short_name: *mut ::std::os::raw::c_char,
    #[doc = " Whether the object is deprecated"]
    pub deprecated: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_PROJ_UNIT_INFO() {
    assert_eq!(
        ::std::mem::size_of::<PROJ_UNIT_INFO>(),
        56usize,
        concat!("Size of: ", stringify!(PROJ_UNIT_INFO))
    );
    assert_eq!(
        ::std::mem::align_of::<PROJ_UNIT_INFO>(),
        8usize,
        concat!("Alignment of ", stringify!(PROJ_UNIT_INFO))
    );
    fn test_field_auth_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PROJ_UNIT_INFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).auth_name) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(PROJ_UNIT_INFO),
                "::",
                stringify!(auth_name)
            )
        );
    }
    test_field_auth_name();
    fn test_field_code() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PROJ_UNIT_INFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).code) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(PROJ_UNIT_INFO),
                "::",
                stringify!(code)
            )
        );
    }
    test_field_code();
    fn test_field_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PROJ_UNIT_INFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(PROJ_UNIT_INFO),
                "::",
                stringify!(name)
            )
        );
    }
    test_field_name();
    fn test_field_category() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PROJ_UNIT_INFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).category) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(PROJ_UNIT_INFO),
                "::",
                stringify!(category)
            )
        );
    }
    test_field_category();
    fn test_field_conv_factor() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PROJ_UNIT_INFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).conv_factor) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(PROJ_UNIT_INFO),
                "::",
                stringify!(conv_factor)
            )
        );
    }
    test_field_conv_factor();
    fn test_field_proj_short_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PROJ_UNIT_INFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).proj_short_name) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(PROJ_UNIT_INFO),
                "::",
                stringify!(proj_short_name)
            )
        );
    }
    test_field_proj_short_name();
    fn test_field_deprecated() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PROJ_UNIT_INFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).deprecated) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(PROJ_UNIT_INFO),
                "::",
                stringify!(deprecated)
            )
        );
    }
    test_field_deprecated();
}
#[doc = " \\brief Structure given description of a celestial body."]
#[doc = ""]
#[doc = " This structure may grow over time, and should not be directly allocated by"]
#[doc = " client code."]
#[doc = " @since 8.1"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PROJ_CELESTIAL_BODY_INFO {
    #[doc = " Authority name."]
    pub auth_name: *mut ::std::os::raw::c_char,
    #[doc = " Object name. For example \"Earth\""]
    pub name: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_PROJ_CELESTIAL_BODY_INFO() {
    assert_eq!(
        ::std::mem::size_of::<PROJ_CELESTIAL_BODY_INFO>(),
        16usize,
        concat!("Size of: ", stringify!(PROJ_CELESTIAL_BODY_INFO))
    );
    assert_eq!(
        ::std::mem::align_of::<PROJ_CELESTIAL_BODY_INFO>(),
        8usize,
        concat!("Alignment of ", stringify!(PROJ_CELESTIAL_BODY_INFO))
    );
    fn test_field_auth_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PROJ_CELESTIAL_BODY_INFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).auth_name) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(PROJ_CELESTIAL_BODY_INFO),
                "::",
                stringify!(auth_name)
            )
        );
    }
    test_field_auth_name();
    fn test_field_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<PROJ_CELESTIAL_BODY_INFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(PROJ_CELESTIAL_BODY_INFO),
                "::",
                stringify!(name)
            )
        );
    }
    test_field_name();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PJ_OBJ_LIST {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " @endcond"]
    pub fn proj_string_list_destroy(list: PROJ_STRING_LIST);
}
extern "C" {
    pub fn proj_context_set_autoclose_database(
        ctx: *mut PJ_CONTEXT,
        autoclose: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn proj_context_set_database_path(
        ctx: *mut PJ_CONTEXT,
        dbPath: *const ::std::os::raw::c_char,
        auxDbPaths: *const *const ::std::os::raw::c_char,
        options: *const *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn proj_context_get_database_path(ctx: *mut PJ_CONTEXT) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn proj_context_get_database_metadata(
        ctx: *mut PJ_CONTEXT,
        key: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn proj_context_get_database_structure(
        ctx: *mut PJ_CONTEXT,
        options: *const *const ::std::os::raw::c_char,
    ) -> PROJ_STRING_LIST;
}
extern "C" {
    pub fn proj_context_guess_wkt_dialect(
        ctx: *mut PJ_CONTEXT,
        wkt: *const ::std::os::raw::c_char,
    ) -> PJ_GUESSED_WKT_DIALECT;
}
extern "C" {
    pub fn proj_create_from_wkt(
        ctx: *mut PJ_CONTEXT,
        wkt: *const ::std::os::raw::c_char,
        options: *const *const ::std::os::raw::c_char,
        out_warnings: *mut PROJ_STRING_LIST,
        out_grammar_errors: *mut PROJ_STRING_LIST,
    ) -> *mut PJ;
}
extern "C" {
    pub fn proj_create_from_database(
        ctx: *mut PJ_CONTEXT,
        auth_name: *const ::std::os::raw::c_char,
        code: *const ::std::os::raw::c_char,
        category: PJ_CATEGORY,
        usePROJAlternativeGridNames: ::std::os::raw::c_int,
        options: *const *const ::std::os::raw::c_char,
    ) -> *mut PJ;
}
extern "C" {
    pub fn proj_uom_get_info_from_database(
        ctx: *mut PJ_CONTEXT,
        auth_name: *const ::std::os::raw::c_char,
        code: *const ::std::os::raw::c_char,
        out_name: *mut *const ::std::os::raw::c_char,
        out_conv_factor: *mut f64,
        out_category: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn proj_grid_get_info_from_database(
        ctx: *mut PJ_CONTEXT,
        grid_name: *const ::std::os::raw::c_char,
        out_full_name: *mut *const ::std::os::raw::c_char,
        out_package_name: *mut *const ::std::os::raw::c_char,
        out_url: *mut *const ::std::os::raw::c_char,
        out_direct_download: *mut ::std::os::raw::c_int,
        out_open_license: *mut ::std::os::raw::c_int,
        out_available: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn proj_clone(ctx: *mut PJ_CONTEXT, obj: *const PJ) -> *mut PJ;
}
extern "C" {
    pub fn proj_create_from_name(
        ctx: *mut PJ_CONTEXT,
        auth_name: *const ::std::os::raw::c_char,
        searchedName: *const ::std::os::raw::c_char,
        types: *const PJ_TYPE,
        typesCount: usize,
        approximateMatch: ::std::os::raw::c_int,
        limitResultCount: usize,
        options: *const *const ::std::os::raw::c_char,
    ) -> *mut PJ_OBJ_LIST;
}
extern "C" {
    pub fn proj_get_type(obj: *const PJ) -> PJ_TYPE;
}
extern "C" {
    pub fn proj_is_deprecated(obj: *const PJ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn proj_get_non_deprecated(ctx: *mut PJ_CONTEXT, obj: *const PJ) -> *mut PJ_OBJ_LIST;
}
extern "C" {
    pub fn proj_is_equivalent_to(
        obj: *const PJ,
        other: *const PJ,
        criterion: PJ_COMPARISON_CRITERION,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn proj_is_equivalent_to_with_ctx(
        ctx: *mut PJ_CONTEXT,
        obj: *const PJ,
        other: *const PJ,
        criterion: PJ_COMPARISON_CRITERION,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn proj_is_crs(obj: *const PJ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn proj_get_name(obj: *const PJ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn proj_get_id_auth_name(
        obj: *const PJ,
        index: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn proj_get_id_code(
        obj: *const PJ,
        index: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn proj_get_remarks(obj: *const PJ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn proj_get_scope(obj: *const PJ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn proj_get_area_of_use(
        ctx: *mut PJ_CONTEXT,
        obj: *const PJ,
        out_west_lon_degree: *mut f64,
        out_south_lat_degree: *mut f64,
        out_east_lon_degree: *mut f64,
        out_north_lat_degree: *mut f64,
        out_area_name: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn proj_as_wkt(
        ctx: *mut PJ_CONTEXT,
        obj: *const PJ,
        type_: PJ_WKT_TYPE,
        options: *const *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn proj_as_proj_string(
        ctx: *mut PJ_CONTEXT,
        obj: *const PJ,
        type_: PJ_PROJ_STRING_TYPE,
        options: *const *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn proj_as_projjson(
        ctx: *mut PJ_CONTEXT,
        obj: *const PJ,
        options: *const *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn proj_get_source_crs(ctx: *mut PJ_CONTEXT, obj: *const PJ) -> *mut PJ;
}
extern "C" {
    pub fn proj_get_target_crs(ctx: *mut PJ_CONTEXT, obj: *const PJ) -> *mut PJ;
}
extern "C" {
    pub fn proj_identify(
        ctx: *mut PJ_CONTEXT,
        obj: *const PJ,
        auth_name: *const ::std::os::raw::c_char,
        options: *const *const ::std::os::raw::c_char,
        out_confidence: *mut *mut ::std::os::raw::c_int,
    ) -> *mut PJ_OBJ_LIST;
}
extern "C" {
    pub fn proj_get_geoid_models_from_database(
        ctx: *mut PJ_CONTEXT,
        auth_name: *const ::std::os::raw::c_char,
        code: *const ::std::os::raw::c_char,
        options: *const *const ::std::os::raw::c_char,
    ) -> PROJ_STRING_LIST;
}
extern "C" {
    pub fn proj_int_list_destroy(list: *mut ::std::os::raw::c_int);
}
extern "C" {
    pub fn proj_get_authorities_from_database(ctx: *mut PJ_CONTEXT) -> PROJ_STRING_LIST;
}
extern "C" {
    pub fn proj_get_codes_from_database(
        ctx: *mut PJ_CONTEXT,
        auth_name: *const ::std::os::raw::c_char,
        type_: PJ_TYPE,
        allow_deprecated: ::std::os::raw::c_int,
    ) -> PROJ_STRING_LIST;
}
extern "C" {
    pub fn proj_get_celestial_body_list_from_database(
        ctx: *mut PJ_CONTEXT,
        auth_name: *const ::std::os::raw::c_char,
        out_result_count: *mut ::std::os::raw::c_int,
    ) -> *mut *mut PROJ_CELESTIAL_BODY_INFO;
}
extern "C" {
    pub fn proj_celestial_body_list_destroy(list: *mut *mut PROJ_CELESTIAL_BODY_INFO);
}
extern "C" {
    pub fn proj_get_crs_list_parameters_create() -> *mut PROJ_CRS_LIST_PARAMETERS;
}
extern "C" {
    pub fn proj_get_crs_list_parameters_destroy(params: *mut PROJ_CRS_LIST_PARAMETERS);
}
extern "C" {
    pub fn proj_get_crs_info_list_from_database(
        ctx: *mut PJ_CONTEXT,
        auth_name: *const ::std::os::raw::c_char,
        params: *const PROJ_CRS_LIST_PARAMETERS,
        out_result_count: *mut ::std::os::raw::c_int,
    ) -> *mut *mut PROJ_CRS_INFO;
}
extern "C" {
    pub fn proj_crs_info_list_destroy(list: *mut *mut PROJ_CRS_INFO);
}
extern "C" {
    pub fn proj_get_units_from_database(
        ctx: *mut PJ_CONTEXT,
        auth_name: *const ::std::os::raw::c_char,
        category: *const ::std::os::raw::c_char,
        allow_deprecated: ::std::os::raw::c_int,
        out_result_count: *mut ::std::os::raw::c_int,
    ) -> *mut *mut PROJ_UNIT_INFO;
}
extern "C" {
    pub fn proj_unit_list_destroy(list: *mut *mut PROJ_UNIT_INFO);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PJ_INSERT_SESSION {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " @endcond"]
    pub fn proj_insert_object_session_create(ctx: *mut PJ_CONTEXT) -> *mut PJ_INSERT_SESSION;
}
extern "C" {
    pub fn proj_insert_object_session_destroy(
        ctx: *mut PJ_CONTEXT,
        session: *mut PJ_INSERT_SESSION,
    );
}
extern "C" {
    pub fn proj_get_insert_statements(
        ctx: *mut PJ_CONTEXT,
        session: *mut PJ_INSERT_SESSION,
        object: *const PJ,
        authority: *const ::std::os::raw::c_char,
        code: *const ::std::os::raw::c_char,
        numeric_codes: ::std::os::raw::c_int,
        allowed_authorities: *const *const ::std::os::raw::c_char,
        options: *const *const ::std::os::raw::c_char,
    ) -> PROJ_STRING_LIST;
}
extern "C" {
    pub fn proj_suggests_code_for(
        ctx: *mut PJ_CONTEXT,
        object: *const PJ,
        authority: *const ::std::os::raw::c_char,
        numeric_code: ::std::os::raw::c_int,
        options: *const *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn proj_string_destroy(str_: *mut ::std::os::raw::c_char);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PJ_OPERATION_FACTORY_CONTEXT {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " @endcond"]
    pub fn proj_create_operation_factory_context(
        ctx: *mut PJ_CONTEXT,
        authority: *const ::std::os::raw::c_char,
    ) -> *mut PJ_OPERATION_FACTORY_CONTEXT;
}
extern "C" {
    pub fn proj_operation_factory_context_destroy(ctx: *mut PJ_OPERATION_FACTORY_CONTEXT);
}
extern "C" {
    pub fn proj_operation_factory_context_set_desired_accuracy(
        ctx: *mut PJ_CONTEXT,
        factory_ctx: *mut PJ_OPERATION_FACTORY_CONTEXT,
        accuracy: f64,
    );
}
extern "C" {
    pub fn proj_operation_factory_context_set_area_of_interest(
        ctx: *mut PJ_CONTEXT,
        factory_ctx: *mut PJ_OPERATION_FACTORY_CONTEXT,
        west_lon_degree: f64,
        south_lat_degree: f64,
        east_lon_degree: f64,
        north_lat_degree: f64,
    );
}
extern "C" {
    pub fn proj_operation_factory_context_set_area_of_interest_name(
        ctx: *mut PJ_CONTEXT,
        factory_ctx: *mut PJ_OPERATION_FACTORY_CONTEXT,
        area_name: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn proj_operation_factory_context_set_crs_extent_use(
        ctx: *mut PJ_CONTEXT,
        factory_ctx: *mut PJ_OPERATION_FACTORY_CONTEXT,
        use_: PROJ_CRS_EXTENT_USE,
    );
}
extern "C" {
    pub fn proj_operation_factory_context_set_spatial_criterion(
        ctx: *mut PJ_CONTEXT,
        factory_ctx: *mut PJ_OPERATION_FACTORY_CONTEXT,
        criterion: PROJ_SPATIAL_CRITERION,
    );
}
extern "C" {
    pub fn proj_operation_factory_context_set_grid_availability_use(
        ctx: *mut PJ_CONTEXT,
        factory_ctx: *mut PJ_OPERATION_FACTORY_CONTEXT,
        use_: PROJ_GRID_AVAILABILITY_USE,
    );
}
extern "C" {
    pub fn proj_operation_factory_context_set_use_proj_alternative_grid_names(
        ctx: *mut PJ_CONTEXT,
        factory_ctx: *mut PJ_OPERATION_FACTORY_CONTEXT,
        usePROJNames: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn proj_operation_factory_context_set_allow_use_intermediate_crs(
        ctx: *mut PJ_CONTEXT,
        factory_ctx: *mut PJ_OPERATION_FACTORY_CONTEXT,
        use_: PROJ_INTERMEDIATE_CRS_USE,
    );
}
extern "C" {
    pub fn proj_operation_factory_context_set_allowed_intermediate_crs(
        ctx: *mut PJ_CONTEXT,
        factory_ctx: *mut PJ_OPERATION_FACTORY_CONTEXT,
        list_of_auth_name_codes: *const *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn proj_operation_factory_context_set_discard_superseded(
        ctx: *mut PJ_CONTEXT,
        factory_ctx: *mut PJ_OPERATION_FACTORY_CONTEXT,
        discard: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn proj_operation_factory_context_set_allow_ballpark_transformations(
        ctx: *mut PJ_CONTEXT,
        factory_ctx: *mut PJ_OPERATION_FACTORY_CONTEXT,
        allow: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn proj_create_operations(
        ctx: *mut PJ_CONTEXT,
        source_crs: *const PJ,
        target_crs: *const PJ,
        operationContext: *const PJ_OPERATION_FACTORY_CONTEXT,
    ) -> *mut PJ_OBJ_LIST;
}
extern "C" {
    pub fn proj_list_get_count(result: *const PJ_OBJ_LIST) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn proj_list_get(
        ctx: *mut PJ_CONTEXT,
        result: *const PJ_OBJ_LIST,
        index: ::std::os::raw::c_int,
    ) -> *mut PJ;
}
extern "C" {
    pub fn proj_list_destroy(result: *mut PJ_OBJ_LIST);
}
extern "C" {
    pub fn proj_get_suggested_operation(
        ctx: *mut PJ_CONTEXT,
        operations: *mut PJ_OBJ_LIST,
        direction: PJ_DIRECTION,
        coord: PJ_COORD,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn proj_crs_is_derived(ctx: *mut PJ_CONTEXT, crs: *const PJ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn proj_crs_get_geodetic_crs(ctx: *mut PJ_CONTEXT, crs: *const PJ) -> *mut PJ;
}
extern "C" {
    pub fn proj_crs_get_horizontal_datum(ctx: *mut PJ_CONTEXT, crs: *const PJ) -> *mut PJ;
}
extern "C" {
    pub fn proj_crs_get_sub_crs(
        ctx: *mut PJ_CONTEXT,
        crs: *const PJ,
        index: ::std::os::raw::c_int,
    ) -> *mut PJ;
}
extern "C" {
    pub fn proj_crs_get_datum(ctx: *mut PJ_CONTEXT, crs: *const PJ) -> *mut PJ;
}
extern "C" {
    pub fn proj_crs_get_datum_ensemble(ctx: *mut PJ_CONTEXT, crs: *const PJ) -> *mut PJ;
}
extern "C" {
    pub fn proj_crs_get_datum_forced(ctx: *mut PJ_CONTEXT, crs: *const PJ) -> *mut PJ;
}
extern "C" {
    pub fn proj_datum_ensemble_get_member_count(
        ctx: *mut PJ_CONTEXT,
        datum_ensemble: *const PJ,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn proj_datum_ensemble_get_accuracy(ctx: *mut PJ_CONTEXT, datum_ensemble: *const PJ)
        -> f64;
}
extern "C" {
    pub fn proj_datum_ensemble_get_member(
        ctx: *mut PJ_CONTEXT,
        datum_ensemble: *const PJ,
        member_index: ::std::os::raw::c_int,
    ) -> *mut PJ;
}
extern "C" {
    pub fn proj_dynamic_datum_get_frame_reference_epoch(
        ctx: *mut PJ_CONTEXT,
        datum: *const PJ,
    ) -> f64;
}
extern "C" {
    pub fn proj_crs_get_coordinate_system(ctx: *mut PJ_CONTEXT, crs: *const PJ) -> *mut PJ;
}
extern "C" {
    pub fn proj_cs_get_type(ctx: *mut PJ_CONTEXT, cs: *const PJ) -> PJ_COORDINATE_SYSTEM_TYPE;
}
extern "C" {
    pub fn proj_cs_get_axis_count(ctx: *mut PJ_CONTEXT, cs: *const PJ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn proj_cs_get_axis_info(
        ctx: *mut PJ_CONTEXT,
        cs: *const PJ,
        index: ::std::os::raw::c_int,
        out_name: *mut *const ::std::os::raw::c_char,
        out_abbrev: *mut *const ::std::os::raw::c_char,
        out_direction: *mut *const ::std::os::raw::c_char,
        out_unit_conv_factor: *mut f64,
        out_unit_name: *mut *const ::std::os::raw::c_char,
        out_unit_auth_name: *mut *const ::std::os::raw::c_char,
        out_unit_code: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn proj_get_ellipsoid(ctx: *mut PJ_CONTEXT, obj: *const PJ) -> *mut PJ;
}
extern "C" {
    pub fn proj_ellipsoid_get_parameters(
        ctx: *mut PJ_CONTEXT,
        ellipsoid: *const PJ,
        out_semi_major_metre: *mut f64,
        out_semi_minor_metre: *mut f64,
        out_is_semi_minor_computed: *mut ::std::os::raw::c_int,
        out_inv_flattening: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn proj_get_celestial_body_name(
        ctx: *mut PJ_CONTEXT,
        obj: *const PJ,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn proj_get_prime_meridian(ctx: *mut PJ_CONTEXT, obj: *const PJ) -> *mut PJ;
}
extern "C" {
    pub fn proj_prime_meridian_get_parameters(
        ctx: *mut PJ_CONTEXT,
        prime_meridian: *const PJ,
        out_longitude: *mut f64,
        out_unit_conv_factor: *mut f64,
        out_unit_name: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn proj_crs_get_coordoperation(ctx: *mut PJ_CONTEXT, crs: *const PJ) -> *mut PJ;
}
extern "C" {
    pub fn proj_coordoperation_get_method_info(
        ctx: *mut PJ_CONTEXT,
        coordoperation: *const PJ,
        out_method_name: *mut *const ::std::os::raw::c_char,
        out_method_auth_name: *mut *const ::std::os::raw::c_char,
        out_method_code: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn proj_coordoperation_is_instantiable(
        ctx: *mut PJ_CONTEXT,
        coordoperation: *const PJ,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn proj_coordoperation_has_ballpark_transformation(
        ctx: *mut PJ_CONTEXT,
        coordoperation: *const PJ,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn proj_coordoperation_get_param_count(
        ctx: *mut PJ_CONTEXT,
        coordoperation: *const PJ,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn proj_coordoperation_get_param_index(
        ctx: *mut PJ_CONTEXT,
        coordoperation: *const PJ,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn proj_coordoperation_get_param(
        ctx: *mut PJ_CONTEXT,
        coordoperation: *const PJ,
        index: ::std::os::raw::c_int,
        out_name: *mut *const ::std::os::raw::c_char,
        out_auth_name: *mut *const ::std::os::raw::c_char,
        out_code: *mut *const ::std::os::raw::c_char,
        out_value: *mut f64,
        out_value_string: *mut *const ::std::os::raw::c_char,
        out_unit_conv_factor: *mut f64,
        out_unit_name: *mut *const ::std::os::raw::c_char,
        out_unit_auth_name: *mut *const ::std::os::raw::c_char,
        out_unit_code: *mut *const ::std::os::raw::c_char,
        out_unit_category: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn proj_coordoperation_get_grid_used_count(
        ctx: *mut PJ_CONTEXT,
        coordoperation: *const PJ,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn proj_coordoperation_get_grid_used(
        ctx: *mut PJ_CONTEXT,
        coordoperation: *const PJ,
        index: ::std::os::raw::c_int,
        out_short_name: *mut *const ::std::os::raw::c_char,
        out_full_name: *mut *const ::std::os::raw::c_char,
        out_package_name: *mut *const ::std::os::raw::c_char,
        out_url: *mut *const ::std::os::raw::c_char,
        out_direct_download: *mut ::std::os::raw::c_int,
        out_open_license: *mut ::std::os::raw::c_int,
        out_available: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn proj_coordoperation_get_accuracy(ctx: *mut PJ_CONTEXT, obj: *const PJ) -> f64;
}
extern "C" {
    pub fn proj_coordoperation_get_towgs84_values(
        ctx: *mut PJ_CONTEXT,
        coordoperation: *const PJ,
        out_values: *mut f64,
        value_count: ::std::os::raw::c_int,
        emit_error_if_incompatible: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn proj_coordoperation_create_inverse(ctx: *mut PJ_CONTEXT, obj: *const PJ) -> *mut PJ;
}
extern "C" {
    pub fn proj_concatoperation_get_step_count(
        ctx: *mut PJ_CONTEXT,
        concatoperation: *const PJ,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn proj_concatoperation_get_step(
        ctx: *mut PJ_CONTEXT,
        concatoperation: *const PJ,
        i_step: ::std::os::raw::c_int,
    ) -> *mut PJ;
}
